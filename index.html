<!DOCTYPE html>
<html>
<head>
  <title>Book list</title>
  <style>
    body { font-family: sans-serif; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ddd; padding: 8px; white-space: pre-wrap; }
    th { background-color: #f2f2f2; text-align: left; }
  </style>
</head>
<body>
  <h1>Works by Author</h1>
  <label for="author-select">Select Author:</label>
  <select id="author-select">
    <option value="http://id.ndl.go.jp/auth/entity/00026849">Karatani Kojin</option>
    <option value="http://id.ndl.go.jp/auth/entity/00138697">Chon Kyongmo</option>
    <option value="http://id.ndl.go.jp/auth/entity/00097630">Yoshimoto Takaaki</option>
    <option value="http://id.ndl.go.jp/auth/entity/001225192">Ryu Shimin</option>
    <option value="http://id.ndl.go.jp/auth/entity/00142627">Lee O-Young</option>
    <option value="http://id.ndl.go.jp/auth/entity/00188634">Kim Yongoak</option>
  </select>

  <h2>Search Authors</h2>
  <label for="author-search-input">Author Name:</label>
  <input type="text" id="author-search-input" placeholder="Enter author name">
  <button id="search-author-button">Search</button>
  <button id="clear-cache-button">Clear Cached Authors</button>
  <div id="author-search-results"></div>
  <p>This table displays works by the selected author, based on a live SPARQL query to <a href="https://jpsearch.go.jp/">JPSearch</a>.</p>
  <table id="results-table">
    <thead>
      <tr>
        <!-- Headers will be populated by JS -->
      </tr>
    </thead>
    <tbody>
      <tr><td colspan="4">Loading...</td></tr>
    </tbody>
  </table>
  <div id="error-container" style="display: none; color: red; background-color: #ffebeb; border: 1px solid red; padding: 10px; margin-top: 20px;">
    <h2>JavaScript Error</h2>
    <pre id="error-message"></pre>
  </div>
  <script>
    window.onerror = function(message, source, lineno, colno, error) {
      document.getElementById('error-container').style.display = 'block';
      document.getElementById('error-message').textContent = 
        `Message: ${message}\nSource: ${source}\nLine: ${lineno}, Column: ${colno}\nError: ${error}`;
      return true; // Prevents the default browser error handling
    };

    const jpsEndpoint = 'https://jpsearch.go.jp/rdf/sparql';
    const ndlEndpoint = 'https://id.ndl.go.jp/auth/ndla/sparql';
    const tableHead = document.querySelector('#results-table thead tr');
    const tableBody = document.querySelector('#results-table tbody');
    const authorSelect = document.getElementById('author-select');

    // IndexedDB setup
    const DB_NAME = 'author_db';
    const DB_VERSION = 1; // Increment this for schema changes
    const STORE_NAME = 'authors';
    const CACHE_SCHEMA_VERSION = '1.0'; // For debugging purposes

    let db;

    function openDb() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onupgradeneeded = (event) => {
          db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: 'id' });
          }
        };

        request.onsuccess = (event) => {
          db = event.target.result;
          console.log('IndexedDB opened successfully');
          resolve(db);
        };

        request.onerror = (event) => {
          console.error('IndexedDB error:', event.target.errorCode);
          reject(event.target.errorCode);
        };
      });
    }

    function addAuthorToDb(author) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.put(author); // Use put to add or update

        request.onsuccess = () => {
          resolve();
        };

        request.onerror = (event) => {
          console.error('Error adding author to DB:', event.target.errorCode);
          reject(event.target.errorCode);
        };
      });
    }

    function getAuthorsFromDb() {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.getAll();

        request.onsuccess = () => {
          resolve(request.result);
        };

        request.onerror = (event) => {
          console.error('Error getting authors from DB:', event.target.errorCode);
          reject(event.target.errorCode);
        };
      });
    }

    async function loadCachedAuthors() {
      try {
        await openDb();

        // Ensure initial HTML options are in IndexedDB
        const initialOptions = Array.from(authorSelect.options);
        for (const option of initialOptions) {
          await addAuthorToDb({ id: option.value, name: option.textContent });
        }

        const authors = await getAuthorsFromDb();

        // Remove all existing options from the select element
        while (authorSelect.firstChild) {
            authorSelect.removeChild(authorSelect.firstChild);
        }

        // Add all authors from IndexedDB to the select element
        // Prepend to ensure newly added (cached) authors appear at the top
        authors.forEach(author => {
            const newOption = document.createElement('option');
            newOption.value = author.id;
            newOption.textContent = author.name;
            authorSelect.prepend(newOption);
        });

        console.log('Cached authors loaded. Cache Schema Version:', CACHE_SCHEMA_VERSION);
      } catch (error) {
        console.error('Failed to load cached authors:', error);
      }
    }

    // Call this on page load
    loadCachedAuthors().then(() => {
      const lastSelectedAuthor = localStorage.getItem('lastSelectedAuthor');
      if (lastSelectedAuthor) {
        authorSelect.value = lastSelectedAuthor;
      }
      fetchWorks(authorSelect.value);
    });

    // Add initial authors to IndexedDB
    Array.from(authorSelect.options).forEach(option => {
      addAuthorToDb({ id: option.value, name: option.textContent });
    });

    function clearAllAuthorsFromDb() {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.clear();

        request.onsuccess = () => {
          console.log('All authors cleared from IndexedDB.');
          resolve();
        };

        request.onerror = (event) => {
          console.error('Error clearing authors from DB:', event.target.errorCode);
          reject(event.target.errorCode);
        };
      });
    }

    const clearCacheButton = document.getElementById('clear-cache-button');
    clearCacheButton.addEventListener('click', async () => {
      if (confirm('Are you sure you want to clear all cached author data?')) {
        await clearAllAuthorsFromDb();
        // Optionally, reload the page or re-populate the select with only initial authors
        location.reload(); 
      }
    });

    function fetchWorks(authorId) {
      const sparqlQuery = `
PREFIX chname: <https://jpsearch.go.jp/entity/chname/>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX schema: <http://schema.org/>
SELECT
min(?d) as ?published
?o as ?title
GROUP_CONCAT(?d; separator="\\n") as ?revisions
group_concat(?s; separator="\\n") AS ?links
WHERE {
{
select * where {
     {
      ?s ?p <${authorId}>;
      rdfs:label ?o;
      schema:datePublished ?d 
     }
     #union
     #{
     # <${authorId}> owl:sameAs ?auth.
     # ?s schema:creator ?auth;
     # rdfs:label ?o;
     # schema:datePublished ?d 
     #}
}
order by ?d ?o
}
}
#group by ?title
order by ?revisions ?published ?title
`;

      const url = `${jpsEndpoint}?query=${encodeURIComponent(sparqlQuery)}&format=json`;

      // Clear previous results and show loading message
      tableHead.innerHTML = '';
      tableBody.innerHTML = '<tr><td colspan="4">Loading...</td></tr>';

      fetch(url)
        .then(res => {
          if (!res.ok) {
            throw new Error(`HTTP error! status: ${res.status}`);
          }
          return res.json();
        })
      .then(data => {
        tableBody.innerHTML = ''; // Clear loading message
        const vars = data.head.vars;
        // Populate headers
        vars.forEach(v => {
          const th = document.createElement('th');
          th.textContent = v;
          tableHead.appendChild(th);
        });

        // Populate rows
        const bindings = data.results.bindings;
        if (bindings.length === 0) {
            const row = document.createElement('tr');
            const cell = document.createElement('td');
            cell.textContent = 'No results found.';
            cell.colSpan = vars.length;
            row.appendChild(cell);
            tableBody.appendChild(row);
            return;
        }

        bindings.forEach(binding => {
          const row = document.createElement('tr');
          vars.forEach(v => {
            const cell = document.createElement('td');
            const value = binding[v] ? binding[v].value : '';
            // Check if the value is a URL and make it a link
	    // split value by newline for revisions and links
	    if (v === 'revisions' || v === 'links') {
	      const values = value.split('\n');
	      const list = document.createElement('ul');
	      values.forEach(val => {
		const listItem = document.createElement('li');
		if (val.startsWith('http')) {
		  const a = document.createElement('a');
		  a.href = val;
		  a.textContent = val;
		  a.target = '_blank'; // Open in new tab
		  listItem.appendChild(a);
		} else {
		  listItem.textContent = val;
		}
		list.appendChild(listItem);
	      });
	      cell.appendChild(list);
	    } else
	    // If not revisions or links, just set the text content
	    if (v === 'published') {
		const date = new Date(value);
		cell.textContent = date.toLocaleDateString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit' });
	    }
	    // If it's a regular value, just set the text content
            
            if (value.startsWith('http')) {
                //const a = document.createElement('a');
                //a.href = value;
                //a.textContent = value;
                //a.target = '_blank'; // Open in new tab
                //cell.appendChild(a);
            } else {
                cell.textContent = value;
            }
            row.appendChild(cell);
          });
          tableBody.appendChild(row);
        });
      })
      .catch(e => {
          console.error('Error fetching or parsing data:', e);
          tableBody.innerHTML = `<tr><td colspan="4" style="text-align: center; color: red;">Error loading data: ${e.message}</td></tr>`;
        });
    }

    

    // Add event listener for author selection change
    authorSelect.addEventListener('change', (event) => {
      fetchWorks(event.target.value);
      localStorage.setItem('lastSelectedAuthor', event.target.value);
    });

    const authorSearchInput = document.getElementById('author-search-input');
    const searchAuthorButton = document.getElementById('search-author-button');
    const authorSearchResults = document.getElementById('author-search-results');

    searchAuthorButton.addEventListener('click', () => {
      const authorName = authorSearchInput.value;
      if (authorName) {
        searchAuthors(authorName);
      }
    });

    function searchAuthors(name) {
      const sparqlQuery = `
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX schema: <http://schema.org/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX xl: <http://www.w3.org/2008/05/skos-xl#>

SELECT ?s ?name ?label ?birthDate ?deathDate
WHERE {
  ?s rdf:type foaf:Person;
     ^foaf:primaryTopic ?ndlna;
     foaf:name ?name.
  OPTIONAL { ?s schema:dateOfBirth ?birthDate. }
  OPTIONAL { ?s schema:dateOfDeath ?deathDate. }
  OPTIONAL { ?ndlna rdfs:label ?label. }
  FILTER regex(?name, "${name}", "i")
}
LIMIT 100
`;

      const url = `${ndlEndpoint}?query=${encodeURIComponent(sparqlQuery)}&format=json`;

      authorSearchResults.innerHTML = 'Loading...';

      fetch(url)
        .then(res => {
          if (!res.ok) {
            throw new Error(`HTTP error! status: ${res.status}`);
          }
          return res.json();
        })
        .then(data => {
          authorSearchResults.innerHTML = '';
          const bindings = data.results && data.results.bindings ? data.results.bindings : [];
          if (bindings.length === 0) {
            authorSearchResults.innerHTML = 'No authors found.';
            return;
          }

          const ul = document.createElement('ul');
          bindings.forEach(binding => {
            const li = document.createElement('li');
            const authorId = binding.s.value;
            const authorName = binding.label.value || binding.name.value;
            const birthDate = binding.birthDate ? ` (${binding.birthDate.value})` : '';
            const deathDate = binding.deathDate ? ` - ${binding.deathDate.value}` : '';
            const a = document.createElement('a');
            a.href = '#';
            a.textContent = `${authorName}${birthDate}${deathDate}`;
            a.addEventListener('click', (e) => {
              e.preventDefault();
              fetchWorks(authorId);
              // Optionally update the author select dropdown
              // if a matching option exists or add a new one
              let optionExists = false;
              for (let i = 0; i < authorSelect.options.length; i++) {
                if (authorSelect.options[i].value === authorId) {
                  authorSelect.selectedIndex = i;
                  optionExists = true;
                  break;
                }
              }
              if (!optionExists) {
                const newOption = document.createElement('option');
                newOption.value = authorId;
                newOption.textContent = authorName;
                authorSelect.prepend(newOption);
                addAuthorToDb({ id: authorId, name: authorName });
              }
              authorSelect.value = authorId;
              localStorage.setItem('lastSelectedAuthor', authorId);
            });
            li.appendChild(a);
            ul.appendChild(li);
          });
          authorSearchResults.appendChild(ul);
        })
        .catch(e => {
          console.error('Error searching authors:', e);
          authorSearchResults.innerHTML = `<span style="color: red;">Error searching authors: ${e.message}</span>`;
        });
    }
  </script>
</body>
</html>
