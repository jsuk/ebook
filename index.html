<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Book list</title>
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      margin: 0;
      padding: 16px;
      line-height: 1.6;
      color: #333;
      background-color: #fff;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    h1 {
      margin-top: 0;
      margin-bottom: 1.5rem;
      font-size: 1.75rem;
    }
    
    h2 {
      margin-top: 2rem;
      margin-bottom: 1rem;
      font-size: 1.25rem;
    }
    
    .form-group {
      margin-bottom: 1rem;
    }
    
    label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 500;
    }
    
    select, input[type="text"] {
      width: 100%;
      padding: 12px;
      border: 2px solid #ddd;
      border-radius: 8px;
      font-size: 16px;
      background-color: #fff;
      transition: border-color 0.2s;
    }
    
    select:focus, input[type="text"]:focus {
      outline: none;
      border-color: #007AFF;
    }
    
    .search-container {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .search-buttons {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    
    button {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      flex: 1;
      min-width: 120px;
    }
    
    #search-author-button {
      background-color: #007AFF;
      color: white;
    }
    
    #search-author-button:hover {
      background-color: #0056CC;
    }
    
    #clear-cache-button {
      background-color: #FF3B30;
      color: white;
    }
    
    #clear-cache-button:hover {
      background-color: #D70015;
    }
    
    button:active {
      transform: translateY(1px);
    }
    
    .table-container {
      overflow-x: auto;
      margin: 1.5rem 0;
      border-radius: 8px;
      border: 1px solid #ddd;
    }
    
    table {
      border-collapse: collapse;
      width: 100%;
      min-width: 600px;
    }
    
    th, td {
      border: 1px solid #ddd;
      padding: 12px;
      text-align: left;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    
    th {
      background-color: #f8f9fa;
      font-weight: 600;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    
    td {
      background-color: #fff;
    }
    
    tr:nth-child(even) td {
      background-color: #f8f9fa;
    }
    
    ul {
      margin: 0;
      padding-left: 1.2rem;
    }
    
    li {
      margin-bottom: 0.25rem;
    }
    
    a {
      color: #007AFF;
      text-decoration: none;
      word-break: break-all;
    }
    
    a:hover {
      text-decoration: underline;
    }
    
    .error-container {
      border-radius: 8px;
      margin-top: 1.5rem;
    }
    
    .search-results {
      margin-top: 1rem;
      padding: 1rem;
      border-radius: 8px;
      background-color: #f8f9fa;
    }
    
    .loading {
      text-align: center;
      padding: 2rem;
      color: #666;
    }
    
    /* Desktop styles */
    @media (min-width: 768px) {
      body {
        padding: 24px;
      }
      
      .search-container {
        flex-direction: row;
        align-items: flex-end;
      }
      
      .search-container input {
        flex: 1;
      }
      
      .search-buttons {
        flex-shrink: 0;
      }
      
      button {
        flex: none;
        min-width: 140px;
      }
      
      h1 {
        font-size: 2rem;
      }
      
      h2 {
        font-size: 1.5rem;
      }
    }
    
    @media (min-width: 1024px) {
      body {
        padding: 32px;
      }
      
      .form-group {
        max-width: 400px;
      }
    }
    
    /* High DPI displays */
    @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
      table {
        font-size: 14px;
      }
      
      th, td {
        padding: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Works by Author</h1>
    
    <div class="form-group">
      <label for="author-select">Select Author:</label>
      <select id="author-select">
        <option value="https://jpsearch.go.jp/entity/chname/柄谷行人">Karatani Kojin</option>
        <option value="http://id.ndl.go.jp/auth/entity/00138697">Chon Kyongmo</option>
        <option value="http://id.ndl.go.jp/auth/entity/00097630">Yoshimoto Takaaki</option>
        <option value="http://id.ndl.go.jp/auth/entity/001225192">Ryu Shimin</option>
        <option value="http://id.ndl.go.jp/auth/entity/00142627">Lee O-Young</option>
        <option value="http://id.ndl.go.jp/auth/entity/00188634">Kim Yongoak</option>
      </select>
    </div>

    <h2>Search Authors</h2>
    <div class="search-container">
      <div class="form-group" style="flex: 1; margin-bottom: 0;">
        <label for="author-search-input">Author Name:</label>
        <input type="text" id="author-search-input" placeholder="Enter author name">
      </div>
      <div class="search-buttons">
        <button id="search-author-button">Search</button>
        <button id="clear-cache-button">Clear Cache</button>
      </div>
    </div>
    
    <div id="author-search-results" class="search-results" style="display: none;"></div>
    
    <p>This table displays works by the selected author, based on a live SPARQL query to <a href="https://jpsearch.go.jp/">JPSearch</a>.</p>
    
    <div class="table-container">
      <table id="results-table">
        <thead>
          <tr>
            <!-- Headers will be populated by JS -->
          </tr>
        </thead>
        <tbody>
          <tr><td colspan="4" class="loading">Loading...</td></tr>
        </tbody>
      </table>
    </div>
  </div>
  <div id="error-container" style="display: none; color: red; background-color: #ffebeb; border: 1px solid red; padding: 10px; margin-top: 20px;">
    <h2>JavaScript Error</h2>
    <pre id="error-message"></pre>
  </div>
  <script>
    window.onerror = function(message, source, lineno, colno, error) {
      document.getElementById('error-container').style.display = 'block';
      document.getElementById('error-message').textContent = 
        `Message: ${message}\nSource: ${source}\nLine: ${lineno}, Column: ${colno}\nError: ${error}`;
      return true; // Prevents the default browser error handling
    };

    const jpsEndpoint = 'https://jpsearch.go.jp/rdf/sparql';
    const ndlEndpoint = 'https://id.ndl.go.jp/auth/ndla/sparql';
    const tableHead = document.querySelector('#results-table thead tr');
    const tableBody = document.querySelector('#results-table tbody');
    const authorSelect = document.getElementById('author-select');

    // IndexedDB setup
    const DB_NAME = 'author_db';
    const DB_VERSION = 1; // Increment this for schema changes
    const STORE_NAME = 'authors';
    const CACHE_SCHEMA_VERSION = '1.0'; // For debugging purposes

    let db;

    function openDb() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onupgradeneeded = (event) => {
          db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: 'id' });
          }
        };

        request.onsuccess = (event) => {
          db = event.target.result;
          console.log('IndexedDB opened successfully');
          resolve(db);
        };

        request.onerror = (event) => {
          console.error('IndexedDB error:', event.target.errorCode);
          reject(event.target.errorCode);
        };
      });
    }

    function addAuthorToDb(author) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.put(author); // Use put to add or update

        request.onsuccess = () => {
          resolve();
        };

        request.onerror = (event) => {
          console.error('Error adding author to DB:', event.target.errorCode);
          reject(event.target.errorCode);
        };
      });
    }

    function getAuthorsFromDb() {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.getAll();

        request.onsuccess = () => {
          resolve(request.result);
        };

        request.onerror = (event) => {
          console.error('Error getting authors from DB:', event.target.errorCode);
          reject(event.target.errorCode);
        };
      });
    }

    async function loadCachedAuthors() {
      try {
        await openDb();

        // Ensure initial HTML options are in IndexedDB
        const initialOptions = Array.from(authorSelect.options);
        for (const option of initialOptions) {
          await addAuthorToDb({ id: option.value, name: option.textContent });
        }

        const authors = await getAuthorsFromDb();

        // Remove all existing options from the select element
        while (authorSelect.firstChild) {
            authorSelect.removeChild(authorSelect.firstChild);
        }

        // Add all authors from IndexedDB to the select element
        // Prepend to ensure newly added (cached) authors appear at the top
        authors.forEach(author => {
            const newOption = document.createElement('option');
            newOption.value = author.id;
            newOption.textContent = author.name;
            authorSelect.prepend(newOption);
        });

        console.log('Cached authors loaded. Cache Schema Version:', CACHE_SCHEMA_VERSION);
      } catch (error) {
        console.error('Failed to load cached authors:', error);
      }
    }

    // Call this on page load
    loadCachedAuthors().then(() => {
      const lastSelectedAuthor = localStorage.getItem('lastSelectedAuthor');
      if (lastSelectedAuthor) {
        authorSelect.value = lastSelectedAuthor;
      }
      fetchWorks(authorSelect.value);
    });

    // Add initial authors to IndexedDB
    Array.from(authorSelect.options).forEach(option => {
      addAuthorToDb({ id: option.value, name: option.textContent });
    });

    function clearAllAuthorsFromDb() {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.clear();

        request.onsuccess = () => {
          console.log('All authors cleared from IndexedDB.');
          resolve();
        };

        request.onerror = (event) => {
          console.error('Error clearing authors from DB:', event.target.errorCode);
          reject(event.target.errorCode);
        };
      });
    }

    const clearCacheButton = document.getElementById('clear-cache-button');
    clearCacheButton.addEventListener('click', async () => {
      if (confirm('Are you sure you want to clear all cached author data?')) {
        await clearAllAuthorsFromDb();
        // Optionally, reload the page or re-populate the select with only initial authors
        location.reload(); 
      }
    });

    function fetchWorks(authorId) {
      const sparqlQuery = `
PREFIX chname: <https://jpsearch.go.jp/entity/chname/>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX schema: <http://schema.org/>
SELECT
min(?d) as ?published
?o as ?title
GROUP_CONCAT(DISTINCT ?d; separator="\\n") as ?revisions
group_concat(DISTINCT ?s; separator="\\n") AS ?links
group_concat(DISTINCT ?isbn; separator="\\n") AS ?isbns
WHERE {
{
select DISTINCT ?s ?o ?d ?isbn where {
     {
      ?s ?p <${authorId}>;
      rdfs:label ?o;
      schema:datePublished ?d .
      OPTIONAL { ?s schema:isbn ?isbn }
     }
     UNION
     {
      ?s schema:creator <${authorId}>;
      rdfs:label ?o;
      schema:datePublished ?d .
      OPTIONAL { ?s schema:isbn ?isbn }
     }
     #union
     #{
     # <${authorId}> owl:sameAs ?auth.
     # ?s schema:creator ?auth;
     # rdfs:label ?o;
     # schema:datePublished ?d 
     #}
}
order by ?d ?o
}
}
#group by ?title
order by ?revisions ?published ?title
`;

      const url = `${jpsEndpoint}?query=${encodeURIComponent(sparqlQuery)}&format=json`;

      // Clear previous results and show loading message
      tableHead.innerHTML = '';
      tableBody.innerHTML = '<tr><td colspan="5">Loading...</td></tr>';

      fetch(url)
        .then(res => {
          if (!res.ok) {
            throw new Error(`HTTP error! status: ${res.status}`);
          }
          return res.json();
        })
      .then(data => {
        tableBody.innerHTML = ''; // Clear loading message
        const vars = data.head.vars;
        // Populate headers
        vars.forEach(v => {
          const th = document.createElement('th');
          th.textContent = v;
          tableHead.appendChild(th);
        });

        // Populate rows
        const bindings = data.results.bindings;
        if (bindings.length === 0) {
            const row = document.createElement('tr');
            const cell = document.createElement('td');
            cell.textContent = 'No results found.';
            cell.colSpan = vars.length;
            row.appendChild(cell);
            tableBody.appendChild(row);
            return;
        }

        bindings.forEach(binding => {
          const row = document.createElement('tr');
          vars.forEach(v => {
            const cell = document.createElement('td');
            const value = binding[v] ? binding[v].value : '';
            // Check if the value is a URL and make it a link
	    // split value by newline for revisions, links, and isbns
	    if (v === 'revisions' || v === 'links' || v === 'isbns') {
	      const values = value.split('\n').filter(val => val.trim() !== '');
	      if (values.length > 0) {
	        const list = document.createElement('ul');
	        values.forEach(val => {
		  const listItem = document.createElement('li');
		  if (val.startsWith('http')) {
		    const a = document.createElement('a');
		    a.href = val;
		    a.textContent = val;
		    a.target = '_blank'; // Open in new tab
		    listItem.appendChild(a);
		  } else {
		    listItem.textContent = val;
		  }
		  list.appendChild(listItem);
	        });
	        cell.appendChild(list);
	      } else {
	        cell.textContent = '-';
	      }
	    } else
	    // If not revisions or links, just set the text content
	    if (v === 'published') {
		const date = new Date(value);
		cell.textContent = date.toLocaleDateString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit' });
	    }
	    // If it's a regular value, just set the text content
            
            if (value.startsWith('http')) {
                //const a = document.createElement('a');
                //a.href = value;
                //a.textContent = value;
                //a.target = '_blank'; // Open in new tab
                //cell.appendChild(a);
            } else if (value) {
                cell.textContent = value;
            } else {
                cell.textContent = '-';
            }
            row.appendChild(cell);
          });
          tableBody.appendChild(row);
        });
      })
      .catch(e => {
          console.error('Error fetching or parsing data:', e);
          tableBody.innerHTML = `<tr><td colspan="4" style="text-align: center; color: red;">Error loading data: ${e.message}</td></tr>`;
        });
    }

    

    // Add event listener for author selection change
    authorSelect.addEventListener('change', (event) => {
      fetchWorks(event.target.value);
      localStorage.setItem('lastSelectedAuthor', event.target.value);
    });

    const authorSearchInput = document.getElementById('author-search-input');
    const searchAuthorButton = document.getElementById('search-author-button');
    const authorSearchResults = document.getElementById('author-search-results');

    searchAuthorButton.addEventListener('click', () => {
      const authorName = authorSearchInput.value;
      if (authorName) {
        searchAuthors(authorName);
      }
    });

    function searchAuthors(name) {
      authorSearchResults.style.display = 'block';
      authorSearchResults.innerHTML = '<div class="loading">Searching authors...</div>';

      // Try AND search first, then fallback to OR if no results
      searchAuthorsWithStrategy(name, 'AND').then(results => {
        if (results.ndlBindings.length === 0 && results.jpSearchBindings.length === 0) {
          // No results with AND, try OR strategy
          console.log('No exact matches found, searching for partial matches...');
          authorSearchResults.innerHTML = '<div class="loading">No exact matches found, searching for partial matches...</div>';
          return searchAuthorsWithStrategy(name, 'OR');
        }
        return results;
      }).then(results => {
        displaySearchResults(results.ndlBindings, results.jpSearchBindings);
      }).catch(e => {
        console.error('Error searching authors:', e);
        authorSearchResults.innerHTML = `<div style="color: #FF3B30; padding: 1rem; background-color: #ffebeb; border-radius: 8px; border: 1px solid #FF3B30;">Error searching authors: ${e.message}</div>`;
      });
    }

    async function searchAuthorsWithStrategy(name, strategy) {
      // Step 1: Search NDL for author entities with all name variants
      const ndlQuery = buildNDLQuery(name, strategy);
      const ndlUrl = `${ndlEndpoint}?query=${encodeURIComponent(ndlQuery)}&format=json`;
      
      const ndlData = await fetch(ndlUrl).then(res => res.ok ? res.json() : Promise.reject(new Error(`NDL query failed: ${res.status}`)));
      const ndlBindings = ndlData.results && ndlData.results.bindings ? ndlData.results.bindings : [];
      
      if (ndlBindings.length === 0) {
        return { ndlBindings: [], jpSearchBindings: [] };
      }
      
      // Step 2: For each NDL author, check if they have JPSearch entity with ISBN data
      const jpSearchPromises = ndlBindings.map(async (binding) => {
        const ndlAuthorId = binding.s.value;
        
        // Query JPSearch to find entity that links back to this NDL entity
        const jpSearchQuery = `
SELECT ?jpEntity WHERE { 
  ?jpEntity <http://www.w3.org/2002/07/owl#sameAs> <${ndlAuthorId}> 
}`;
        
        const jpUrl = `${jpsEndpoint}?query=${encodeURIComponent(jpSearchQuery)}&format=json`;
        
        try {
          const jpData = await fetch(jpUrl).then(res => res.ok ? res.json() : null);
          const hasJPSearchEntity = jpData && jpData.results && jpData.results.bindings && jpData.results.bindings.length > 0;
          
          if (hasJPSearchEntity) {
            const jpSearchURI = jpData.results.bindings[0].jpEntity.value;
            return {
              creator: { value: jpSearchURI },
              authorName: { value: jpSearchURI.split('/').pop() }
            };
          }
          return null;
        } catch (error) {
          console.error('JPSearch lookup failed for', ndlAuthorId, error);
          return null;
        }
      });
      
      const jpSearchResults = await Promise.all(jpSearchPromises);
      const jpSearchBindings = jpSearchResults.filter(result => result !== null);
      
      return {
        ndlBindings: ndlBindings,
        jpSearchBindings: jpSearchBindings
      };
    }

    function buildJPSearchQuery(name, strategy) {
      const searchWords = name.toLowerCase().split(/\s+/).filter(w => w.length > 0);
      
      if (searchWords.length <= 1) {
        // Single word - use simple search
        const searchFilters = `CONTAINS(LCASE(?authorName), "${searchWords[0]}") || ` +
          `CONTAINS(LCASE(REPLACE(?authorName, "_", " ")), "${searchWords[0]}") || ` +
          `CONTAINS(LCASE(REPLACE(?authorName, ",_", ", ")), "${searchWords[0]}")`;
        
        return `
PREFIX schema: <http://schema.org/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>

SELECT DISTINCT ?creator ?authorName
WHERE {
  ?s schema:creator ?creator ;
     schema:isbn ?isbn .
  BIND(REPLACE(STR(?creator), ".*/", "") AS ?authorName)
  FILTER(${searchFilters})
}
LIMIT 20`;
      }

      // Multi-word search with AND/OR strategy
      const wordFilters = searchWords.map(word => 
        `(CONTAINS(LCASE(?authorName), "${word}") || ` +
        `CONTAINS(LCASE(REPLACE(?authorName, "_", " ")), "${word}") || ` +
        `CONTAINS(LCASE(REPLACE(?authorName, ",_", ", ")), "${word}"))`
      );

      const joinOperator = strategy === 'AND' ? ' && ' : ' || ';
      const searchFilters = wordFilters.join(joinOperator);

      return `
PREFIX schema: <http://schema.org/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>

SELECT DISTINCT ?creator ?authorName
WHERE {
  ?s schema:creator ?creator ;
     schema:isbn ?isbn .
  BIND(REPLACE(STR(?creator), ".*/", "") AS ?authorName)
  FILTER(${searchFilters})
}
LIMIT 20`;
    }

    function buildNDLQuery(name, strategy) {
      const searchWords = name.toLowerCase().split(/\s+/).filter(w => w.length > 0);
      
      if (searchWords.length <= 1) {
        // Single word search
        return `
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX schema: <http://schema.org/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX skosxl: <http://www.w3.org/2008/05/skos-xl#>
PREFIX ndl: <http://ndl.go.jp/dcndl/terms/>

SELECT DISTINCT ?s ?name ?label ?birthDate ?deathDate ?transcription
WHERE {
  ?s rdf:type foaf:Person;
     ^foaf:primaryTopic ?ndlna;
     foaf:name ?name.
  OPTIONAL { ?s schema:dateOfBirth ?birthDate. }
  OPTIONAL { ?s schema:dateOfDeath ?deathDate. }
  OPTIONAL { ?ndlna rdfs:label ?label. }
  OPTIONAL { 
    { ?ndlna skosxl:prefLabel ?prefLabel . ?prefLabel ndl:transcription ?transcription . }
    UNION
    { ?ndlna skosxl:altLabel ?altLabel . ?altLabel ndl:transcription ?transcription . }
  }
  FILTER (
    regex(?name, "${searchWords[0]}", "i") || 
    regex(?label, "${searchWords[0]}", "i") ||
    regex(?transcription, "${searchWords[0]}", "i")
  )
}
LIMIT 50`;
      }
      
      // Multi-word search with AND/OR strategy
      const wordFilters = searchWords.map(word => 
        `(regex(?name, "${word}", "i") || regex(?label, "${word}", "i") || regex(?transcription, "${word}", "i"))`
      );
      
      const joinOperator = strategy === 'AND' ? ' && ' : ' || ';
      const searchFilters = wordFilters.join(joinOperator);
      
      return `
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX schema: <http://schema.org/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX skosxl: <http://www.w3.org/2008/05/skos-xl#>
PREFIX ndl: <http://ndl.go.jp/dcndl/terms/>

SELECT DISTINCT ?s ?name ?label ?birthDate ?deathDate ?transcription
WHERE {
  ?s rdf:type foaf:Person;
     ^foaf:primaryTopic ?ndlna;
     foaf:name ?name.
  OPTIONAL { ?s schema:dateOfBirth ?birthDate. }
  OPTIONAL { ?s schema:dateOfDeath ?deathDate. }
  OPTIONAL { ?ndlna rdfs:label ?label. }
  OPTIONAL { 
    { ?ndlna skosxl:prefLabel ?prefLabel . ?prefLabel ndl:transcription ?transcription . }
    UNION
    { ?ndlna skosxl:altLabel ?altLabel . ?altLabel ndl:transcription ?transcription . }
  }
  FILTER (${searchFilters})
}
LIMIT 50`;
    }

    function displaySearchResults(ndlBindings, jpSearchBindings) {
      if (ndlBindings.length === 0 && jpSearchBindings.length === 0) {
        authorSearchResults.innerHTML = '<div style="color: #666;">No authors found.</div>';
        return;
      }
      
      // Merge and deduplicate authors
      const mergedAuthors = mergeAuthorResults(ndlBindings, jpSearchBindings);
      
      authorSearchResults.innerHTML = '';
      const ul = document.createElement('ul');
      
      mergedAuthors.forEach(author => {
        const li = document.createElement('li');
        createAuthorLink(li, author.preferredId, author.displayName, author.baseName);
        ul.appendChild(li);
      });
      
      authorSearchResults.appendChild(ul);
    }

    // Function to merge and deduplicate author results
    function mergeAuthorResults(ndlBindings, jpSearchBindings) {
      const authorMap = new Map();
      
      // Process NDL results first
      ndlBindings.forEach(binding => {
        const authorId = binding.s.value;
        const authorName = binding.label.value || binding.name.value;
        const birthDate = binding.birthDate ? binding.birthDate.value : null;
        const deathDate = binding.deathDate ? binding.deathDate.value : null;
        const transcription = binding.transcription ? binding.transcription.value : null;
        
        // Extract base name (remove punctuation and spaces for matching)
        const baseName = normalizeAuthorName(authorName);
        
        const author = {
          ndlId: authorId,
          ndlName: authorName,
          baseName: baseName,
          birthDate: birthDate,
          deathDate: deathDate,
          transcription: transcription,
          hasISBN: false,
          jpSearchId: null
        };
        
        authorMap.set(baseName, author);
      });
      
      // Process JPSearch results and merge with NDL
      jpSearchBindings.forEach(binding => {
        const authorId = binding.creator.value;
        const authorName = binding.authorName.value;
        const baseName = normalizeAuthorName(authorName);
        
        if (authorMap.has(baseName)) {
          // Merge with existing NDL entry
          const existing = authorMap.get(baseName);
          existing.hasISBN = true;
          existing.jpSearchId = authorId;
        } else {
          // New author not in NDL
          const author = {
            ndlId: null,
            ndlName: null,
            baseName: baseName,
            birthDate: null,
            deathDate: null,
            transcription: null,
            hasISBN: true,
            jpSearchId: authorId,
            jpSearchName: authorName
          };
          authorMap.set(baseName, author);
        }
      });
      
      // Convert to array with display formatting
      return Array.from(authorMap.values()).map(author => {
        let displayName, preferredId;
        
        if (author.hasISBN) {
          // Prefer ISBN version, use NDL name if available for better formatting
          displayName = author.ndlName || author.jpSearchName || author.baseName;
          if (author.transcription) displayName += ` / ${author.transcription}`;
          if (author.birthDate) displayName += ` (${author.birthDate})`;
          if (author.deathDate) displayName += ` - ${author.deathDate}`;
          displayName += ' 📚'; // ISBN indicator
          preferredId = author.jpSearchId;
        } else {
          // No ISBN version available
          displayName = author.ndlName;
          if (author.transcription) displayName += ` / ${author.transcription}`;
          if (author.birthDate) displayName += ` (${author.birthDate})`;
          if (author.deathDate) displayName += ` - ${author.deathDate}`;
          preferredId = author.ndlId;
        }
        
        return {
          preferredId: preferredId,
          displayName: displayName,
          baseName: author.baseName,
          hasISBN: author.hasISBN
        };
      });
    }
    
    // Normalize author names for matching
    function normalizeAuthorName(name) {
      if (!name) return '';
      // Remove common punctuation, spaces, dates, and convert to lowercase for matching
      return name
        .replace(/,\s*\d{4}[\-\d]*\s*$/g, '')     // Remove trailing dates like ", 1953-"
        .replace(/[,\s\-\(\)（）_]/g, '')          // Remove punctuation, spaces, and underscores
        .toLowerCase();
    }

    // Helper function to create author links
    function createAuthorLink(li, authorId, displayName, authorName) {
      const a = document.createElement('a');
      a.href = '#';
      a.textContent = displayName;
      a.addEventListener('click', (e) => {
        e.preventDefault();
        fetchWorks(authorId);
        
        // Update the author select dropdown
        let optionExists = false;
        for (let i = 0; i < authorSelect.options.length; i++) {
          if (authorSelect.options[i].value === authorId) {
            authorSelect.selectedIndex = i;
            optionExists = true;
            break;
          }
        }
        if (!optionExists) {
          const newOption = document.createElement('option');
          newOption.value = authorId;
          newOption.textContent = displayName;
          authorSelect.prepend(newOption);
          addAuthorToDb({ id: authorId, name: displayName });
        }
        authorSelect.value = authorId;
        localStorage.setItem('lastSelectedAuthor', authorId);
      });
      li.appendChild(a);
    }
  </script>
</body>
</html>
