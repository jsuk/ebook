<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Book list</title>
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      margin: 0;
      padding: 16px;
      line-height: 1.6;
      color: #333;
      background-color: #fff;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    h1 {
      margin-top: 0;
      margin-bottom: 1.5rem;
      font-size: 1.75rem;
    }
    
    h2 {
      margin-top: 2rem;
      margin-bottom: 1rem;
      font-size: 1.25rem;
    }
    
    .form-group {
      margin-bottom: 1rem;
    }
    
    label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 500;
    }
    
    select, input[type="text"] {
      width: 100%;
      padding: 12px;
      border: 2px solid #ddd;
      border-radius: 8px;
      font-size: 16px;
      background-color: #fff;
      transition: border-color 0.2s;
    }
    
    select:focus, input[type="text"]:focus {
      outline: none;
      border-color: #007AFF;
    }
    
    .search-container {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .search-buttons {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    
    button {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      flex: 1;
      min-width: 120px;
    }
    
    #search-author-button {
      background-color: #007AFF;
      color: white;
    }
    
    #search-author-button:hover {
      background-color: #0056CC;
    }
    
    #clear-cache-button {
      background-color: #FF3B30;
      color: white;
    }
    
    #clear-cache-button:hover {
      background-color: #D70015;
    }
    
    button:active {
      transform: translateY(1px);
    }
    
    .table-container {
      overflow-x: auto;
      margin: 1.5rem 0;
      border-radius: 8px;
      border: 1px solid #ddd;
    }
    
    table {
      border-collapse: collapse;
      width: 100%;
      min-width: 600px;
    }
    
    th, td {
      border: 1px solid #ddd;
      padding: 12px;
      text-align: left;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    
    th {
      background-color: #f8f9fa;
      font-weight: 600;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    
    td {
      background-color: #fff;
    }
    
    tr:nth-child(even) td {
      background-color: #f8f9fa;
    }
    
ul {
      margin: 0;
      padding-left: 1.2rem;
    }
    
    li {
      margin-bottom: 0.25rem;
    }
    
    a {
      color: #007AFF;
      text-decoration: none;
      word-break: break-all;
    }
    
a:hover {
      text-decoration: underline;
    }
    
    .error-container {
      border-radius: 8px;
      margin-top: 1.5rem;
    }
    
    .search-results {
      margin-top: 1rem;
      padding: 1rem;
      border-radius: 8px;
      background-color: #f8f9fa;
    }
    
    .loading {
      text-align: center;
      padding: 2rem;
      color: #666;
      position: relative;
      animation: pulse 2s infinite;
    }
    
    .loading::after {
      content: '';
      display: inline-block;
      width: 20px;
      height: 20px;
      margin-left: 10px;
      border: 2px solid #ddd;
      border-top: 2px solid #007AFF;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      vertical-align: middle;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    /* Smooth transitions for results */
    .search-results {
      transition: all 0.3s ease;
      opacity: 0;
      animation: fadeIn 0.5s ease forwards;
    }
    
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    /* Performance optimizations */
    * {
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
    }
    
    table {
      transform: translateZ(0);
      will-change: scroll-position;
    }
    
    /* Desktop styles */
    @media (min-width: 768px) {
      body {
        padding: 24px;
      }
      
      .search-container {
        flex-direction: row;
        align-items: flex-end;
      }
      
      .search-container input {
        flex: 1;
      }
      
      .search-buttons {
        flex-shrink: 0;
      }
      
      button {
        flex: none;
        min-width: 140px;
      }
      
      h1 {
        font-size: 2rem;
      }
      
      h2 {
        font-size: 1.5rem;
      }
    }
    
    @media (min-width: 1024px) {
      body {
        padding: 32px;
      }
      
      .form-group {
        max-width: 400px;
      }
    }
    
    /* High DPI displays */
    @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
      table {
        font-size: 14px;
      }
      
      th, td {
        padding: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Works by Author</h1>
    
    <div class="form-group">
      <label for="author-select">Select Author:</label>
      <select id="author-select">
        <option value="https://jpsearch.go.jp/entity/chname/柄谷行人">Karatani Kojin</option>
        <option value="http://lod.nl.go.kr/resource/KAC200203105">Karatani Kojin (KNL)</option>
        <option value="http://lod.nl.go.kr/resource/KAC201116642">Yoo Simin (KNL)</option>
        <option value="http://id.ndl.go.jp/auth/entity/00138697">Chon Kyongmo</option>
        <option value="http://id.ndl.go.jp/auth/entity/00097630">Yoshimoto Takaaki</option>
        <option value="http://id.ndl.go.jp/auth/entity/001225192">Ryu Shimin</option>
        <option value="http://id.ndl.go.jp/auth/entity/00142627">Lee O-Young</option>
        <option value="http://id.ndl.go.jp/auth/entity/00188634">Kim Yongoak</option>
      </select>
    </div>

    <h2>Search Authors</h2>
    <div class="search-container">
      <div class="form-group" style="flex: 1; margin-bottom: 0;">
        <label for="author-search-input">Author Name:</label>
        <input type="text" id="author-search-input" placeholder="Enter author name">
      </div>
      <div class="search-buttons">
        <button id="search-author-button">Search</button>
        <button id="clear-cache-button">Clear Cache</button>
      </div>
    </div>
    
    <div id="author-search-results" class="search-results" style="display: none;"></div>
    
    <p>This table displays works by the selected author, based on live SPARQL queries to <a href="https://jpsearch.go.jp/">JPSearch</a> and <a href="https://lod.nl.go.kr/">Korean National Library</a>.</p>
    
    <div id="knl-status" style="display: none; padding: 8px; margin: 10px 0; border-radius: 4px; font-size: 0.9em;"></div>
    
    <div id="debug-info" style="display: none; padding: 8px; margin: 10px 0; border-radius: 4px; font-size: 0.8em; background-color: #f8f9fa; border: 1px solid #dee2e6;">
      <h4>🔧 Debug Information</h4>
      <div id="debug-content"></div>
    </div>
    
    <div class="table-container">
      <table id="results-table">
        <thead>
          <tr>
            <!-- Headers will be populated by JS -->
          </tr>
        </thead>
        <tbody>
          <tr><td colspan="4" class="loading">Loading...</td></tr>
        </tbody>
      </table>
    </div>

  </div>
  <div id="error-container" style="display: none; color: red; background-color: #ffebeb; border: 1px solid red; padding: 10px; margin-top: 20px;">
    <h2>JavaScript Error</h2>
    <pre id="error-message"></pre>
  </div>
  <script src="sparql-queries.js"></script>
  <script>
    window.onerror = function(message, source, lineno, colno, error) {
      document.getElementById('error-container').style.display = 'block';
      document.getElementById('error-message').textContent = 
        `Message: ${message}\nSource: ${source}\nLine: ${lineno}, Column: ${colno}\nError: ${error}`;
      return true; // Prevents the default browser error handling
    };

    const jpsEndpoint = 'https://jpsearch.go.jp/rdf/sparql';
    const ndlEndpoint = 'https://id.ndl.go.jp/auth/ndla/sparql';
    const knlEndpoint = 'https://lod.nl.go.kr/sparql';
    const tableHead = document.querySelector('#results-table thead tr');
    const tableBody = document.querySelector('#results-table tbody');
    const authorSelect = document.getElementById('author-select');

    // Global array to track all SPARQL queries for debugging
    let executedQueries = [];

    // Function to log SPARQL queries for debugging
    function logQuery(endpoint, query, queryName, status = 'executing', results = 0, error = null, url = null) {
      // Validate query using SparqlUtils if available
      let validation = { valid: true, issues: [] };
      if (typeof SparqlUtils !== 'undefined') {
        const extractedAuthorId = SparqlUtils.extractAuthorId(query);
        const queryType = SparqlUtils.getQueryType(query);
        
        if (!extractedAuthorId) {
          validation.issues.push('No author ID found in query');
          validation.valid = false;
        }
        
        validation.authorId = extractedAuthorId;
        validation.queryType = queryType;
      }
      
      const logEntry = {
        timestamp: new Date().toISOString(),
        endpoint: endpoint,
        queryName: queryName,
        query: query.trim(),
        status: status,
        resultCount: results,
        error: error,
        validation: validation
      };
      
      // Add the full executable URL if provided
      if (url) {
        logEntry.executableUrl = url;
      }
      
      executedQueries.push(logEntry);
      console.log(`🔍 SPARQL Query logged: ${endpoint} - ${queryName} - ${status}`);
      console.log('📋 Complete query:', query.trim());
      
      if (!validation.valid) {
        console.warn('⚠️ Query validation issues:', validation.issues);
      }
    }

    // Function to clear query log for new searches
    function clearQueryLog() {
      executedQueries = [];
    }

    // Function to HTML encode text for safe display
    function htmlEncode(str) {
      return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    // IndexedDB setup
    const DB_NAME = 'author_db';
    const DB_VERSION = 2; // Increment this for schema changes
    const STORE_NAME = 'authors';
    const WORKS_STORE_NAME = 'works_cache';
    const CACHE_SCHEMA_VERSION = '2.0'; // For debugging purposes
    const WORKS_CACHE_DURATION = 10 * 60 * 1000; // 10 minutes

    let db;

    function openDb() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onupgradeneeded = (event) => {
          db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: 'id' });
          }
          if (!db.objectStoreNames.contains(WORKS_STORE_NAME)) {
            db.createObjectStore(WORKS_STORE_NAME, { keyPath: 'authorId' });
          }
        };

        request.onsuccess = (event) => {
          db = event.target.result;
          console.log('IndexedDB opened successfully');
          resolve(db);
        };

        request.onerror = (event) => {
          console.error('IndexedDB error:', event.target.errorCode);
          reject(event.target.errorCode);
        };
      });
    }

    function addAuthorToDb(author) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.put(author); // Use put to add or update

        request.onsuccess = () => {
          resolve();
        };

        request.onerror = (event) => {
          console.error('Error adding author to DB:', event.target.errorCode);
          reject(event.target.errorCode);
        };
      });
    }

    function getAuthorsFromDb() {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.getAll();

        request.onsuccess = () => {
          resolve(request.result);
        };

        request.onerror = (event) => {
          console.error('Error getting authors from DB:', event.target.errorCode);
          reject(event.target.errorCode);
        };
      });
    }

    async function loadCachedAuthors() {
      try {
        await openDb();

        // Ensure initial HTML options are in IndexedDB
        const initialOptions = Array.from(authorSelect.options);
        for (const option of initialOptions) {
          await addAuthorToDb({ id: option.value, name: option.textContent });
        }

        const authors = await getAuthorsFromDb();

        // Remove all existing options from the select element
        while (authorSelect.firstChild) {
            authorSelect.removeChild(authorSelect.firstChild);
        }

        // Add all authors from IndexedDB to the select element
        // Prepend to ensure newly added (cached) authors appear at the top
        authors.forEach(author => {
            const newOption = document.createElement('option');
            newOption.value = author.id;
            newOption.textContent = author.name;
            authorSelect.prepend(newOption);
        });

        console.log('Cached authors loaded. Cache Schema Version:', CACHE_SCHEMA_VERSION);
      } catch (error) {
        console.error('Failed to load cached authors:', error);
      }
    }

    // Check KNL proxy status on page load
    async function checkKNLStatus() {
      try {
        const response = await fetch('http://localhost:8001/', { 
          method: 'GET',
          signal: AbortSignal.timeout(3000) // 3 second timeout
        });
        
        const statusDiv = document.getElementById('knl-status');
        if (response.ok) {
          statusDiv.style.display = 'block';
          statusDiv.style.backgroundColor = '#d4edda';
          statusDiv.style.color = '#155724';
          statusDiv.style.border = '1px solid #c3e6cb';
          statusDiv.innerHTML = '✅ KNL (Korean National Library) search is available';
        }
      } catch (error) {
        const statusDiv = document.getElementById('knl-status');
        statusDiv.style.display = 'block';
        statusDiv.style.backgroundColor = '#f8d7da';
        statusDiv.style.color = '#721c24';
        statusDiv.style.border = '1px solid #f5c6cb';
        statusDiv.innerHTML = '⚠️ KNL (Korean National Library) search is unavailable - proxy not running. JPSearch and NDL still work normally.';
        console.info('KNL proxy not detected - KNL searches will be disabled');
      }
    }

    // Call this on page load
    loadCachedAuthors().then(() => {
      const lastSelectedAuthor = localStorage.getItem('lastSelectedAuthor');
      if (lastSelectedAuthor) {
        authorSelect.value = lastSelectedAuthor;
      }
      fetchWorks(authorSelect.value);
      checkKNLStatus(); // Check KNL availability
    });

    // Add initial authors to IndexedDB
    Array.from(authorSelect.options).forEach(option => {
      addAuthorToDb({ id: option.value, name: option.textContent });
    });

    function clearAllAuthorsFromDb() {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME, WORKS_STORE_NAME], 'readwrite');
        const authorsStore = transaction.objectStore(STORE_NAME);
        const worksStore = transaction.objectStore(WORKS_STORE_NAME);
        
        const clearAuthors = authorsStore.clear();
        const clearWorks = worksStore.clear();

        Promise.all([
          new Promise((res, rej) => {
            clearAuthors.onsuccess = res;
            clearAuthors.onerror = rej;
          }),
          new Promise((res, rej) => {
            clearWorks.onsuccess = res;
            clearWorks.onerror = rej;
          })
        ]).then(() => {
          console.log('All cached data cleared from IndexedDB.');
          resolve();
        }).catch((error) => {
          console.error('Error clearing cache from DB:', error);
          reject(error);
        });
      });
    }

    function cacheWorksData(authorId, jpResults, knlResults) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([WORKS_STORE_NAME], 'readwrite');
        const store = transaction.objectStore(WORKS_STORE_NAME);
        
        const cacheEntry = {
          authorId: authorId,
          jpResults: jpResults,
          knlResults: knlResults,
          timestamp: Date.now()
        };
        
        const request = store.put(cacheEntry);
        request.onsuccess = () => resolve();
        request.onerror = (event) => {
          console.error('Error caching works data:', event.target.errorCode);
          reject(event.target.errorCode);
        };
      });
    }

    function getCachedWorksData(authorId) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([WORKS_STORE_NAME], 'readonly');
        const store = transaction.objectStore(WORKS_STORE_NAME);
        const request = store.get(authorId);

        request.onsuccess = () => {
          const result = request.result;
          if (result && (Date.now() - result.timestamp < WORKS_CACHE_DURATION)) {
            resolve(result);
          } else {
            resolve(null); // Cache expired or not found
          }
        };

        request.onerror = (event) => {
          console.error('Error getting cached works data:', event.target.errorCode);
          resolve(null); // Return null on error to proceed with fresh fetch
        };
      });
    }

    const clearCacheButton = document.getElementById('clear-cache-button');
    clearCacheButton.addEventListener('click', async () => {
      if (confirm('Are you sure you want to clear all cached data (authors and works)?')) {
        await clearAllAuthorsFromDb();
        console.log('All cached data cleared - page will reload');
        // Optionally, reload the page or re-populate the select with only initial authors
        location.reload(); 
      }
    });

    async function fetchWorks(authorId) {
      // Clear query log for this new search
      clearQueryLog();
      
      // Clear previous results and show loading message
      tableHead.innerHTML = '';
      tableBody.innerHTML = '<tr><td colspan="6" class="loading">🔍 Checking cache...</td></tr>';

      try {
        // Check cache first
        const cachedData = await getCachedWorksData(authorId);
        if (cachedData) {
          console.log('Using cached works data for:', authorId);
          tableBody.innerHTML = '<tr><td colspan="6" class="loading">📚 Loading from cache...</td></tr>';
          await new Promise(resolve => setTimeout(resolve, 100)); // Brief delay for UX
          displayUnifiedResults(cachedData.jpResults, cachedData.knlResults);
          return;
        }

        // Detect author locale based on ID
        const detectedLocale = detectAuthorLocale(authorId);
        const config = localeConfig[detectedLocale];
        console.log(`🔍 Author locale: ${detectedLocale} | Target endpoints: ${config.endpoints.join(', ')}`);

        // No cache, proceed with fresh fetch
        tableBody.innerHTML = `<tr><td colspan="6" class="loading">🔍 Initializing ${detectedLocale} search...</td></tr>`;
        
        let jpResults = null, knlResults = null;
        let jpStatus = 'pending', knlStatus = 'pending';
        
        // Progress callback to update loading status in real-time
        const updateProgressStatus = (source, status) => {
          if (source === 'jp') jpStatus = status;
          if (source === 'knl') knlStatus = status;
          
          let statusText = `🔍 ${detectedLocale} search: `;
          const statuses = [];
          
          if (config.endpoints.includes('jpsearch') && jpStatus !== 'completed' && jpStatus !== 'skipped') {
            statuses.push(jpStatus);
          }
          if (config.endpoints.includes('knl') && knlStatus !== 'completed' && knlStatus !== 'skipped') {
            statuses.push(knlStatus);
          }
          
          if (statuses.length > 0) {
            statusText += statuses.join(' | ');
          } else {
            const skipped = ['jpsearch', 'knl'].filter(ep => !config.endpoints.includes(ep));
            if (skipped.length > 0) {
              statusText = `⚡ ${detectedLocale} optimized (skipped: ${skipped.join(', ')}) | 💾 Caching...`;
            } else {
              statusText = '💾 Caching results...';
            }
          }
          
          tableBody.innerHTML = `<tr><td colspan="6" class="loading">${statusText}</td></tr>`;
        };
        
        // Create progress callbacks for each source
        const jpProgressCallback = (status) => updateProgressStatus('jp', status);
        const knlProgressCallback = (status) => updateProgressStatus('knl', status);
        
        // Start only relevant searches based on detected locale
        const searchPromises = [];
        
        if (config.endpoints.includes('jpsearch')) {
          const jpPromise = fetchJPSearchWorks(authorId, jpProgressCallback).then(result => {
            jpResults = result;
            jpStatus = 'completed';
            updateProgressStatus('jp', 'completed');
            return result;
          });
          searchPromises.push(jpPromise);
        } else {
          jpResults = { source: 'JPSearch', bindings: [], vars: [] };
          jpStatus = 'skipped';
        }
        
        if (config.endpoints.includes('knl')) {
          const knlPromise = fetchKNLWorks(authorId, knlProgressCallback).then(result => {
            knlResults = result;
            knlStatus = 'completed';
            updateProgressStatus('knl', 'completed');
            return result;
          });
          searchPromises.push(knlPromise);
        } else {
          knlResults = { source: 'KNL', bindings: [], vars: [] };
          knlStatus = 'skipped';
        }
        
        // Wait only for the endpoints we're actually searching
        if (searchPromises.length > 0) {
          await Promise.all(searchPromises);
        }
        
        // Cache the results
        tableBody.innerHTML = '<tr><td colspan="6" class="loading">💾 Caching results...</td></tr>';
        try {
          await cacheWorksData(authorId, jpResults, knlResults);
          console.log('Works data cached for:', authorId);
        } catch (e) {
          console.warn('Failed to cache works data:', e);
        }
        
        // Final processing message
        tableBody.innerHTML = '<tr><td colspan="6" class="loading">📊 Processing and displaying results...</td></tr>';
        
        // Small delay to show processing message
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Log performance summary with optimization info
        const totalJPResults = jpResults.bindings ? jpResults.bindings.length : 0;
        const totalKNLResults = knlResults.bindings ? knlResults.bindings.length : 0;
        const skippedEndpoints = ['jpsearch', 'knl'].filter(ep => !config.endpoints.includes(ep));
        
        console.log(`⚡ Locale-optimized results (${detectedLocale}): JPSearch: ${totalJPResults}, KNL: ${totalKNLResults}`);
        if (skippedEndpoints.length > 0) {
          console.log(`🚀 Performance boost: Skipped ${skippedEndpoints.join(', ')} endpoints`);
        }

        // Always show debug info for now to help troubleshoot
        showDebugInfo(authorId, detectedLocale, config, jpResults, knlResults);

        // Union and display results
        displayUnifiedResults(jpResults, knlResults);
        
      } catch (e) {
        console.error('Error fetching works:', e);
        tableBody.innerHTML = `<tr><td colspan="6" style="text-align: center; color: #FF3B30; background-color: #ffebeb; padding: 2rem;">
          <strong>Error Loading Works</strong><br>
          ${e.message}<br>
          <small>Please try selecting the author again or check your connection.</small>
        </td></tr>`;
      }
    }

    async function fetchJPSearchWorks(authorId, progressCallback) {
      const allResults = [];
      let queryCount = 0;

      // Use SPARQL query from external module
      console.log(`🔍 JPSearch: Building query for authorId: ${authorId}`);
      const query1 = SparqlQueries.jpSearch.worksByAuthor(authorId);
      console.log(`📋 JPSearch: Complete query built:`, query1);
      console.log(`🔧 Query type: ${SparqlUtils.getQueryType(query1)}`);

      // For now, disable the ?p query which might not be working properly
      const query2 = null;

      const queries = [
        { query: query1, name: 'schema:creator works' }
      ].filter(q => q.query !== null); // Only include non-null queries

      try {
        for (const { query, name } of queries) {
          queryCount++;
          if (progressCallback) {
            progressCallback(`📚 JPSearch: ${name} (${queryCount}/${queries.length})`);
          }

          // Retry logic for failed queries
          let attempts = 0;
          const maxAttempts = 3;
          let success = false;
          
          while (attempts < maxAttempts && !success) {
            try {
              attempts++;
              if (attempts > 1 && progressCallback) {
                progressCallback(`📚 JPSearch: ${name} (retry ${attempts}/${maxAttempts})`);
              }
              
              const url = `${jpsEndpoint}?query=${encodeURIComponent(query)}&format=json`;
              
              // Log the complete executable query with URL
              logQuery(jpsEndpoint, query, name, 'executing', 0, null, url);
              
              const response = await fetch(url, { 
                timeout: 30000 // 30 second timeout for complex queries
              });
              
              if (!response.ok) {
                if (attempts === maxAttempts) {
                  throw new Error(`JPSearch HTTP error! status: ${response.status}`);
                }
                console.warn(`JPSearch ${name} attempt ${attempts} failed: ${response.status}, retrying...`);
                await new Promise(resolve => setTimeout(resolve, 1000 * attempts)); // Exponential backoff
                continue;
              }
              
              const data = await response.json();
              console.log(`JPSearch ${name} response:`, data);
              
              if (data.results && data.results.bindings && Array.isArray(data.results.bindings)) {
                console.log(`JPSearch ${name} - Raw bindings:`, data.results.bindings.slice(0, 2));
                allResults.push(...data.results.bindings);
                console.log(`JPSearch ${name}: ${data.results.bindings.length} results added, total: ${allResults.length}`);
                
                // Log successful query
                logQuery(jpsEndpoint, query, name, 'completed', data.results.bindings.length, null, url);
                success = true;
              } else {
                console.warn(`JPSearch ${name}: No results structure found`);
                console.warn('Response structure:', Object.keys(data || {}));
                
                // Log query with no results
                logQuery(jpsEndpoint, query, name, 'no_results', 0, null, url);
                success = true; // Don't retry for empty results
              }
              
            } catch (fetchError) {
              if (attempts === maxAttempts) {
                console.error(`JPSearch ${name} failed after ${maxAttempts} attempts:`, fetchError);
                // Log failed query
                logQuery(jpsEndpoint, query, name, 'error', 0, fetchError.message, url);
                // Continue with other queries even if one fails
              } else {
                console.warn(`JPSearch ${name} attempt ${attempts} failed:`, fetchError.message);
                await new Promise(resolve => setTimeout(resolve, 1000 * attempts)); // Exponential backoff
              }
            }
          }
          
          // Brief pause to allow UI to update and show progress
          await new Promise(resolve => setTimeout(resolve, 100));
        }

        // Group results by title and aggregate data client-side
        const groupedResults = groupJPSearchResults(allResults);
        
        return {
          source: 'JPSearch',
          bindings: groupedResults,
          vars: ['published', 'title', 'revisions', 'links', 'isbns']
        };
      } catch (e) {
        console.error('JPSearch error:', e);
        return { source: 'JPSearch', bindings: [], vars: [], error: e.message };
      }
    }

    // Group JPSearch results by title and aggregate metadata
    function groupJPSearchResults(rawResults) {
      console.log('Processing raw JPSearch results:', rawResults.length, 'items');
      console.log('First few items:', rawResults.slice(0, 3));
      
      const grouped = new Map();
      
      rawResults.forEach((item, index) => {
        const title = item.o ? item.o.value : '';
        const published = item.d ? item.d.value : '';
        const workLink = item.s ? item.s.value : ''; // URI of the work itself  
        const directLink = item.link ? item.link.value : ''; // Direct URL if available
        const isbn = item.isbn ? item.isbn.value : ''; // This might be undefined now
        
        const bestLink = directLink || workLink; // Prefer direct URLs over work URIs
        console.log(`Item ${index}: title="${title}", published="${published}", workLink="${workLink}", directLink="${directLink}"`);
        
        if (!title) {
          console.warn(`Skipping item ${index} - no title`);
          return; // Skip items without title
        }
        
        const key = title;
        if (!grouped.has(key)) {
          grouped.set(key, {
            title: { value: title },
            published: { value: published },
            revisions: { value: published },
            links: { value: bestLink },
            isbns: { value: isbn || '' }
          });
        } else {
          // Merge additional data
          const existing = grouped.get(key);
          
          // Keep earliest publication date
          if (published && (!existing.published.value || published < existing.published.value)) {
            existing.published.value = published;
          }
          
          // Accumulate revisions (dates)
          if (published && existing.revisions.value && !existing.revisions.value.includes(published)) {
            existing.revisions.value += ',' + published;
          }
          
          // Accumulate links
          if (bestLink && existing.links.value && !existing.links.value.includes(bestLink)) {
            existing.links.value += ',' + bestLink;
          }
          
          // Accumulate ISBNs
          if (isbn && existing.isbns.value && !existing.isbns.value.includes(isbn)) {
            existing.isbns.value += ',' + isbn;
          }
        }
      });
      
      const result = Array.from(grouped.values());
      console.log('Grouped JPSearch results:', result.length, 'unique works');
      console.log('Sample grouped result:', result[0]);
      
      return result;
    }

    // Show debug information when no results are found
    function showDebugInfo(authorId, detectedLocale, config, jpResults, knlResults) {
      const debugDiv = document.getElementById('debug-info');
      const debugContent = document.getElementById('debug-content');
      
      // Generate SPARQL queries section
      let queriesHtml = '';
      if (executedQueries.length > 0) {
        queriesHtml = `
          <h5>🔍 Executed SPARQL Queries (${executedQueries.length} total)</h5>
          <div style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; margin: 10px 0; background-color: #f9f9f9;">
        `;
        
        executedQueries.forEach((q, index) => {
          const statusColor = q.status === 'completed' ? '#28a745' : 
                             q.status === 'error' ? '#dc3545' : 
                             q.status === 'no_results' ? '#ffc107' : '#6c757d';
          
          queriesHtml += `
            <div style="margin-bottom: 15px; padding: 10px; border-left: 4px solid ${statusColor}; background-color: white;">
              <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 5px;">
                <strong>Query ${index + 1}: ${q.queryName}</strong>
                <span style="margin-left: auto; font-size: 0.8em; color: ${statusColor};">
                  ${q.status.toUpperCase()} (${q.resultCount} results)
                </span>
              </div>
              <div style="font-size: 0.8em; color: #666; margin-bottom: 5px;">
                <strong>Endpoint:</strong> ${q.endpoint} | 
                <strong>Time:</strong> ${new Date(q.timestamp).toLocaleTimeString()}
                ${q.validation ? ` | <strong>Type:</strong> ${q.validation.queryType}` : ''}
                ${q.validation && q.validation.authorId ? ` | <strong>Author ID:</strong> ${q.validation.authorId.substring(q.validation.authorId.lastIndexOf('/') + 1)}` : ''}
                ${q.error ? ` | <strong style="color: #dc3545;">Error:</strong> ${q.error}` : ''}
                ${q.validation && !q.validation.valid ? ` | <strong style="color: #dc3545;">⚠️ Issues:</strong> ${q.validation.issues.join(', ')}` : ''}
              </div>
              <details style="margin-top: 5px;">
                <summary style="cursor: pointer; font-size: 0.8em; color: #007AFF;">Show Complete SPARQL Query & URLs</summary>
                <div style="margin: 5px 0;">
                  <strong style="font-size: 0.8em;">📋 Executable SPARQL Query:</strong>
                  <pre style="background-color: #f8f9fa; padding: 10px; margin: 5px 0; overflow-x: auto; font-size: 0.7em; white-space: pre-wrap; border: 1px solid #dee2e6;">${htmlEncode(q.query)}</pre>
                  ${q.executableUrl ? `
                    <strong style="font-size: 0.8em;">🔗 Executable URL(s):</strong>
                    <pre style="background-color: #e7f3ff; padding: 10px; margin: 5px 0; overflow-x: auto; font-size: 0.7em; white-space: pre-wrap; border: 1px solid #b3d9ff;">${htmlEncode(q.executableUrl)}</pre>
                    <div style="margin-top: 5px;">
                      <button onclick="navigator.clipboard.writeText('${q.query.replace(/'/g, "\\'")}'); alert('SPARQL query copied to clipboard!');" 
                              style="font-size: 0.7em; padding: 2px 8px; margin-right: 5px; background: #007AFF; color: white; border: none; border-radius: 3px; cursor: pointer;">
                        Copy Query
                      </button>
                      <button onclick="navigator.clipboard.writeText('${q.executableUrl.replace(/'/g, "\\'")}'); alert('URL copied to clipboard!');" 
                              style="font-size: 0.7em; padding: 2px 8px; margin-right: 5px; background: #28a745; color: white; border: none; border-radius: 3px; cursor: pointer;">
                        Copy URL
                      </button>
                      <button onclick="window.open('${q.executableUrl.split('\\n')[0].replace('Direct: ', '')}', '_blank');" 
                              style="font-size: 0.7em; padding: 2px 8px; background: #ffc107; color: black; border: none; border-radius: 3px; cursor: pointer;">
                        🚀 Test Query
                      </button>
                    </div>
                  ` : ''}
                </div>
              </details>
            </div>
          `;
        });
        
        queriesHtml += '</div>';
      } else {
        queriesHtml = '<p><em>No SPARQL queries executed yet.</em></p>';
      }
      
      let debugHtml = `
        <p><strong>Author ID:</strong> ${authorId}</p>
        <p><strong>Detected Locale:</strong> ${detectedLocale}</p>
        <p><strong>Target Endpoints:</strong> ${config.endpoints.join(', ')}</p>
        <p><strong>JPSearch Status:</strong> ${jpResults.error || 'OK'} (${jpResults.bindings ? jpResults.bindings.length : 0} results)</p>
        <p><strong>KNL Status:</strong> ${knlResults.error || 'OK'} (${knlResults.bindings ? knlResults.bindings.length : 0} results)</p>
        
        ${queriesHtml}
        
        <h5>🛠️ Troubleshooting</h5>
        <ul>
          <li>Try clearing cache and reloading</li>
          <li>Check if CORS proxy is running on port 8001 for KNL</li>
          <li>Verify the author ID is correct in the database</li>
          <li>Try searching for the author by name instead</li>
          <li>Review SPARQL queries above for syntax errors</li>
        </ul>
      `;
      
      debugContent.innerHTML = debugHtml;
      debugDiv.style.display = 'block';
    }

    async function fetchKNLWorks(authorId, progressCallback) {
      // Check if this is a KNL author URI
      let knlAuthorId = authorId;
      
      console.log(`🔍 fetchKNLWorks called with authorId: "${authorId}" (type: ${typeof authorId})`);
      
      if (!authorId || !authorId.startsWith('http://lod.nl.go.kr/')) {
        console.log(`❌ Not a KNL URI, returning empty results for: ${authorId}`);
        // If it's not a KNL URI, return empty results for non-KNL authors
        return Promise.resolve({ source: 'KNL', bindings: [], vars: [] });
      }

      if (progressCallback) {
        progressCallback('🇰🇷 KNL: Loading works...');
      }

      console.log(`🇰🇷 KNL: Building query for knlAuthorId: ${knlAuthorId}`);
      const sparqlQuery = SparqlQueries.knl.worksByAuthor(knlAuthorId);
      console.log(`📋 KNL: Complete query built:`, sparqlQuery);
      console.log(`🔧 Query type: ${SparqlUtils.getQueryType(sparqlQuery)}`);

      // Prepare URLs outside try block for access in catch block
      const knlDirectUrl = `${knlEndpoint}?query=${encodeURIComponent(sparqlQuery)}&format=json&type=json`;
      const url = `http://localhost:8001/?url=${encodeURIComponent(knlDirectUrl)}`;

      try {
        // Log the KNL query being executed with both proxy URL and direct URL
        logQuery('KNL (via proxy)', sparqlQuery, 'works query', 'executing', 0, null, `Direct: ${knlDirectUrl}\nProxy: ${url}`);

        // Add retry logic for KNL queries
        let attempts = 0;
        const maxAttempts = 2;
        
        while (attempts < maxAttempts) {
          attempts++;
          try {
            if (progressCallback && attempts > 1) {
              progressCallback(`🇰🇷 KNL: Loading works... (retry ${attempts}/${maxAttempts})`);
            }
            
            const response = await fetch(url, {
              timeout: 15000 // 15 second timeout for KNL
            });
            
            if (!response.ok) {
              if (response.status === 0 || response.status >= 500) {
                if (attempts === maxAttempts) {
                  throw new Error('KNL proxy not available');
                }
                console.warn(`KNL attempt ${attempts} failed: ${response.status}, retrying...`);
                await new Promise(resolve => setTimeout(resolve, 2000));
                continue;
              }
              throw new Error(`KNL HTTP error! status: ${response.status}`);
            }
            
            const responseText = await response.text();
            console.log('KNL raw response:', responseText.substring(0, 200) + '...');
            
            let data;
            try {
              data = JSON.parse(responseText);
            } catch (jsonError) {
              console.warn('KNL JSON parse error:', jsonError.message);
              console.warn('Response text:', responseText);
              
              // If it's an error response from proxy, extract the error
              if (responseText.includes('"error"')) {
                try {
                  const errorData = JSON.parse(responseText);
                  throw new Error(`KNL proxy error: ${errorData.error}`);
                } catch {
                  throw new Error('KNL returned invalid JSON format');
                }
              } else {
                throw new Error('KNL returned non-JSON response');
              }
            }
            
            const resultCount = data.results ? data.results.bindings.length : 0;
            console.log(`KNL: ${resultCount} results after ${attempts} attempt(s)`);
            
            // Log successful KNL query
            logQuery('KNL (via proxy)', sparqlQuery, 'works query', 'completed', resultCount, null, `Direct: ${knlDirectUrl}\nProxy: ${url}`);
            
            return {
              source: 'KNL',
              bindings: data.results ? data.results.bindings : [],
              vars: data.head ? data.head.vars : []
            };
            
          } catch (fetchError) {
            if (attempts === maxAttempts) {
              throw fetchError;
            }
            console.warn(`KNL attempt ${attempts} failed:`, fetchError.message);
            await new Promise(resolve => setTimeout(resolve, 2000));
          }
        }
      } catch (e) {
        // Log failed KNL query
        logQuery('KNL (via proxy)', sparqlQuery, 'works query', 'error', 0, e.message, `Direct: ${knlDirectUrl}\nProxy: ${url}`);
        
        if (e.message.includes('proxy not available')) {
          console.warn('KNL proxy is not running - KNL work search disabled');
        } else if (e.message.includes('timeout')) {
          console.warn('KNL query timed out - endpoint may be slow');
        } else {
          console.error('KNL error:', e);
        }
        return { source: 'KNL', bindings: [], vars: [], error: e.message };
      }
    }

    function displayUnifiedResults(jpResults, knlResults) {
      // Create unified headers: published, title, source, revisions, links, isbns
      const unifiedHeaders = ['published', 'title', 'source', 'revisions', 'links', 'isbns'];
      
      // Clear and populate headers
      tableHead.innerHTML = '';
      unifiedHeaders.forEach(header => {
        const th = document.createElement('th');
        th.textContent = header;
        tableHead.appendChild(th);
      });

      // Clear table body
      tableBody.innerHTML = '';

      // Convert and combine results with deduplication
      const workMap = new Map();
      
      // Process JPSearch results
      if (jpResults.bindings && jpResults.bindings.length > 0) {
        jpResults.bindings.forEach(binding => {
          const work = {
            published: binding.published ? binding.published.value : '',
            title: binding.title ? binding.title.value : '',
            source: 'JPSearch',
            revisions: binding.revisions ? binding.revisions.value : '',
            links: binding.links ? binding.links.value : '',
            isbns: binding.isbns ? binding.isbns.value : ''
          };
          
          // Use title + publication year as deduplication key
          const pubYear = work.published ? new Date(work.published).getFullYear() : 'unknown';
          const dedupeKey = `${work.title}_${pubYear}`;
          workMap.set(dedupeKey, work);
        });
      }

      // Process KNL results - avoid duplicates with JPSearch
      if (knlResults.bindings && knlResults.bindings.length > 0) {
        knlResults.bindings.forEach(binding => {
          const work = {
            published: binding.issued ? binding.issued.value : '',
            title: binding.title ? binding.title.value : '',
            source: 'KNL',
            revisions: '',
            links: binding.work ? binding.work.value : '',
            isbns: binding.isbn ? binding.isbn.value : ''
          };
          
          // Use title + publication year as deduplication key
          const pubYear = work.published ? new Date(work.published).getFullYear() : 'unknown';
          const dedupeKey = `${work.title}_${pubYear}`;
          
          // Only add if not already present from JPSearch
          if (!workMap.has(dedupeKey)) {
            workMap.set(dedupeKey, work);
          } else {
            // If we have the same work from both sources, merge the information
            const existing = workMap.get(dedupeKey);
            existing.source = 'JPSearch + KNL';
            if (!existing.isbns && work.isbns) existing.isbns = work.isbns;
            if (!existing.links && work.links) existing.links = work.links;
          }
        });
      }
      
      // Convert to array
      const allResults = Array.from(workMap.values());

      // Sort results by publication date
      allResults.sort((a, b) => {
        const dateA = new Date(a.published || '0000');
        const dateB = new Date(b.published || '0000');
        return dateA - dateB;
      });

      // Display results
      if (allResults.length === 0) {
        const row = document.createElement('tr');
        const cell = document.createElement('td');
        cell.textContent = 'No results found in either JPSearch or KNL.';
        cell.colSpan = unifiedHeaders.length;
        row.appendChild(cell);
        tableBody.appendChild(row);
        return;
      }

      allResults.forEach(result => {
        const row = document.createElement('tr');
        
        unifiedHeaders.forEach(header => {
          const cell = document.createElement('td');
          const value = result[header] || '';
          
          if (header === 'published' && value) {
            const date = new Date(value);
            cell.textContent = date.toLocaleDateString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit' });
          } else if (header === 'revisions' || header === 'links' || header === 'isbns') {
            const values = value.split(',').filter(val => val.trim() !== '');
            if (values.length > 0) {
              const list = document.createElement('ul');
              values.forEach(val => {
                const listItem = document.createElement('li');
                if (val.startsWith('http')) {
                  const a = document.createElement('a');
                  a.href = val;
                  a.textContent = val;
                  a.target = '_blank';
                  listItem.appendChild(a);
                } else {
                  listItem.textContent = val;
                }
                list.appendChild(listItem);
              });
              cell.appendChild(list);
            } else {
              cell.textContent = '-';
            }
          } else if (header === 'source') {
            // Add visual indicator for source
            cell.textContent = value;
            if (value === 'KNL') {
              cell.style.backgroundColor = '#e3f2fd';
              cell.style.fontWeight = 'bold';
            } else if (value === 'JPSearch') {
              cell.style.backgroundColor = '#f3e5f5';
              cell.style.fontWeight = 'bold';
            }
          } else {
            cell.textContent = value || '-';
          }
          
          row.appendChild(cell);
        });
        
        tableBody.appendChild(row);
      });

      // Show summary
      const summaryMessage = `Found ${jpResults.bindings ? jpResults.bindings.length : 0} results from JPSearch and ${knlResults.bindings ? knlResults.bindings.length : 0} results from KNL (${allResults.length} total)`;
      console.log(summaryMessage);
    }

    

    // Add event listener for author selection change
    authorSelect.addEventListener('change', (event) => {
      const authorId = event.target.value;
      fetchWorks(authorId);
      localStorage.setItem('lastSelectedAuthor', event.target.value);
    });

    const authorSearchInput = document.getElementById('author-search-input');
    const searchAuthorButton = document.getElementById('search-author-button');
    const authorSearchResults = document.getElementById('author-search-results');
    
    let searchTimeout;
    let currentSearchController;

    // Debounced search on input
    authorSearchInput.addEventListener('input', () => {
      const authorName = authorSearchInput.value.trim();
      
      // Cancel previous timeout
      if (searchTimeout) {
        clearTimeout(searchTimeout);
      }
      
      // Cancel previous request
      if (currentSearchController) {
        currentSearchController.abort();
      }
      
      if (authorName.length === 0) {
        authorSearchResults.style.display = 'none';
        return;
      }
      
      if (authorName.length >= 2) {
        // Show immediate loading state
        authorSearchResults.style.display = 'block';
        authorSearchResults.innerHTML = '<div class="loading">Searching as you type...</div>';
        
        // Debounce search by 300ms
        searchTimeout = setTimeout(() => {
          searchAuthors(authorName);
        }, 300);
      }
    });

    // Manual search button
    searchAuthorButton.addEventListener('click', () => {
      const authorName = authorSearchInput.value.trim();
      if (authorName) {
        // Cancel debounced search
        if (searchTimeout) {
          clearTimeout(searchTimeout);
        }
        searchAuthors(authorName);
      }
    });
    
    // Enter key support
    authorSearchInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        const authorName = authorSearchInput.value.trim();
        if (authorName) {
          if (searchTimeout) {
            clearTimeout(searchTimeout);
          }
          searchAuthors(authorName);
        }
      }
    });

    function searchAuthors(name) {
      // Create new AbortController for this search
      currentSearchController = new AbortController();
      const signal = currentSearchController.signal;
      
      authorSearchResults.style.display = 'block';
      authorSearchResults.innerHTML = '<div class="loading">🔍 Searching authors...</div>';

      // Try AND search first, then fallback to OR if no results
      searchAuthorsWithStrategy(name, 'AND', signal).then(results => {
        // Check if request was cancelled
        if (signal.aborted) return;
        
        if (results.ndlBindings.length === 0 && results.jpSearchBindings.length === 0 && results.knlBindings.length === 0) {
          // No results with AND, try OR strategy
          console.log('No exact matches found, searching for partial matches...');
          authorSearchResults.innerHTML = '<div class="loading">🔍 No exact matches, searching partial matches...</div>';
          return searchAuthorsWithStrategy(name, 'OR', signal);
        }
        return results;
      }).then(results => {
        // Check if request was cancelled
        if (signal.aborted) return;
        
        displaySearchResults(results.ndlBindings, results.jpSearchBindings, results.knlBindings, {
          detectedLanguage: results.detectedLanguage,
          skippedEndpoints: results.skippedEndpoints
        });
      }).catch(e => {
        // Don't show error if request was cancelled
        if (e.name === 'AbortError' || signal.aborted) {
          console.log('Search cancelled');
          return;
        }
        
        console.error('Error searching authors:', e);
        authorSearchResults.innerHTML = `<div style="color: #FF3B30; padding: 1rem; background-color: #ffebeb; border-radius: 8px; border: 1px solid #FF3B30;">
          <strong>Search Error:</strong> ${e.message}<br>
          <small>Please try again or check your connection.</small>
        </div>`;
      });
    }

    async function searchAuthorsWithStrategy(name, strategy, signal = null) {
      const startTime = performance.now();
      const detectedLang = detectLanguage(name);
      const config = localeConfig[detectedLang];
      
      console.log(`🔍 Search: "${name}" | Language: ${detectedLang} | Strategy: ${strategy}`);
      console.log(`📍 Target endpoints: ${config.endpoints.join(', ')}`);
      
      let ndlResults = { ndlBindings: [], jpSearchBindings: [] };
      let jpSearchResults = [];
      let knlResults = [];
      
      try {
        // Search only relevant endpoints based on detected language
        const searchPromises = [];
        
        if (config.endpoints.includes('ndl')) {
          searchPromises.push(
            searchNDLAuthors(name, strategy, signal)
              .then(result => { ndlResults = result; return result; })
          );
        }
        
        if (config.endpoints.includes('jpsearch')) {
          searchPromises.push(
            searchJPSearchAuthors(name, strategy, signal)
              .then(result => { jpSearchResults = result; return result; })
          );
        }
        
        if (config.endpoints.includes('knl')) {
          searchPromises.push(
            searchKNLAuthors(name, strategy, signal)
              .then(result => { knlResults = result; return result; })
          );
        }
        
        // Wait only for the endpoints we're actually searching
        await Promise.all(searchPromises);
        
        const duration = performance.now() - startTime;
        console.log(`⚡ Locale-optimized search completed in ${Math.round(duration)}ms`);
        console.log('Search results summary:', {
          ndl: ndlResults.ndlBindings ? ndlResults.ndlBindings.length : 0,
          jpFromNDL: ndlResults.jpSearchBindings ? ndlResults.jpSearchBindings.length : 0, 
          jpDirect: jpSearchResults ? jpSearchResults.length : 0,
          knl: knlResults ? knlResults.length : 0
        });
        
        // Combine JPSearch results from NDL linkage and direct search
        const allJPSearchBindings = [
          ...(ndlResults.jpSearchBindings || []),
          ...(jpSearchResults || [])
        ];
        
        return {
          ndlBindings: ndlResults.ndlBindings || [],
          jpSearchBindings: allJPSearchBindings,
          knlBindings: knlResults || [],
          detectedLanguage: detectedLang,
          skippedEndpoints: ['jpsearch', 'ndl', 'knl'].filter(ep => !config.endpoints.includes(ep))
        };
      } catch (error) {
        console.error('Error in locale-aware search:', error);
        return {
          ndlBindings: [],
          jpSearchBindings: [],
          knlBindings: [],
          detectedLanguage: detectedLang,
          error: error.message
        };
      }
    }

    async function searchNDLAuthors(name, strategy, signal = null) {
      // Step 1: Search NDL for author entities with all name variants
      const ndlQuery = buildNDLQuery(name, strategy);
      const ndlUrl = `${ndlEndpoint}?query=${encodeURIComponent(ndlQuery)}&format=json`;
      
      const fetchOptions = signal ? { signal } : {};
      const ndlData = await fetch(ndlUrl, fetchOptions).then(res => res.ok ? res.json() : Promise.reject(new Error(`NDL query failed: ${res.status}`)));
      const ndlBindings = ndlData.results && ndlData.results.bindings ? ndlData.results.bindings : [];
      
      if (ndlBindings.length === 0) {
        return { ndlBindings: [], jpSearchBindings: [] };
      }
      
      // Step 2: For each NDL author, check if they have JPSearch entity with ISBN data
      const jpSearchPromises = ndlBindings.map(async (binding) => {
        const ndlAuthorId = binding.s.value;
        
        // Query JPSearch to find entity that links back to this NDL entity
        const jpSearchQuery = `
SELECT ?jpEntity WHERE { 
  ?jpEntity <http://www.w3.org/2002/07/owl#sameAs> <${ndlAuthorId}> 
}`;
        
        const jpUrl = `${jpsEndpoint}?query=${encodeURIComponent(jpSearchQuery)}&format=json`;
        
        try {
          const jpData = await fetch(jpUrl, fetchOptions).then(res => res.ok ? res.json() : null);
          const hasJPSearchEntity = jpData && jpData.results && jpData.results.bindings && jpData.results.bindings.length > 0;
          
          if (hasJPSearchEntity) {
            const jpSearchURI = jpData.results.bindings[0].jpEntity.value;
            return {
              ndlId: ndlAuthorId,
              creator: { value: jpSearchURI },
              authorName: { value: jpSearchURI.split('/').pop() }
            };
          }
          return null;
        } catch (error) {
          console.error('JPSearch lookup failed for', ndlAuthorId, error);
          return null;
        }
      });
      
      const jpSearchResults = await Promise.all(jpSearchPromises);
      const jpSearchBindings = jpSearchResults.filter(result => result !== null);
      
      return {
        ndlBindings: ndlBindings,
        jpSearchBindings: jpSearchBindings
      };
    }

    async function searchJPSearchAuthors(name, strategy, signal = null) {
      // Enhanced JPSearch author search with global authority identifiers
      const jpQuery = `
PREFIX schema: <http://schema.org/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>

SELECT DISTINCT ?creator ?authorName ?viafId ?wikidataId ?dbpediaId WHERE {
  ?s schema:creator ?creator ;
     schema:isbn ?isbn .
  BIND(REPLACE(STR(?creator), ".*/", "") AS ?authorName)
  
  OPTIONAL { ?creator owl:sameAs ?viafUri . FILTER(CONTAINS(STR(?viafUri), "viaf.org")) BIND(?viafUri AS ?viafId) }
  OPTIONAL { ?creator owl:sameAs ?wikidataUri . FILTER(CONTAINS(STR(?wikidataUri), "wikidata.org")) BIND(?wikidataUri AS ?wikidataId) }  
  OPTIONAL { ?creator owl:sameAs ?dbpediaUri . FILTER(CONTAINS(STR(?dbpediaUri), "dbpedia.org")) BIND(?dbpediaUri AS ?dbpediaId) }
  
  FILTER(CONTAINS(LCASE(?authorName), "${name.toLowerCase()}") || 
         CONTAINS(LCASE(REPLACE(?authorName, "_", " ")), "${name.toLowerCase()}"))
}
LIMIT 20`;

      const jpUrl = `${jpsEndpoint}?query=${encodeURIComponent(jpQuery)}&format=json`;
      const fetchOptions = signal ? { signal } : {};
      
      try {
        const jpData = await fetch(jpUrl, fetchOptions).then(res => res.ok ? res.json() : null);
        return jpData && jpData.results && jpData.results.bindings ? jpData.results.bindings : [];
      } catch (error) {
        if (error.name === 'AbortError') throw error;
        console.error('Enhanced JPSearch author search failed:', error);
        return [];
      }
    }

    // Simple in-memory cache for search results
    const searchCache = new Map();
    const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
    const QUERY_TIMEOUT = 15000; // 15 second timeout for queries
    
    // Performance monitoring
    const performanceMetrics = {
      searchTimes: [],
      cacheHits: 0,
      cacheMisses: 0
    };

    // Language detection utility
    function detectLanguage(text) {
      if (!text || typeof text !== 'string') return 'unknown';
      
      text = text.trim();
      
      // Korean detection - Hangul characters
      const koreanRegex = /[\uac00-\ud7af\u1100-\u11ff\u3130-\u318f]/;
      if (koreanRegex.test(text)) {
        return 'korean';
      }
      
      // Japanese detection - Hiragana, Katakana, Kanji
      const japaneseRegex = /[\u3040-\u309f\u30a0-\u30ff\u4e00-\u9faf]/;
      if (japaneseRegex.test(text)) {
        return 'japanese';
      }
      
      // Chinese detection (simplified/traditional) - CJK ideographs without Japanese kana
      const chineseRegex = /[\u4e00-\u9fff]/;
      if (chineseRegex.test(text) && !japaneseRegex.test(text)) {
        return 'chinese';
      }
      
      // English/Latin detection
      const latinRegex = /^[a-zA-Z\s\-\.',]+$/;
      if (latinRegex.test(text)) {
        return 'english';
      }
      
      return 'mixed'; // Mixed or unknown script
    }

    // Detect author locale based on URI/ID patterns
    function detectAuthorLocale(authorId) {
      if (!authorId) return 'unknown';
      
      // Korean National Library
      if (authorId.includes('lod.nl.go.kr')) {
        return 'korean';
      }
      
      // JPSearch entities (Japanese)
      if (authorId.includes('jpsearch.go.jp')) {
        return 'japanese';
      }
      
      // NDL entities (could be Japanese or international)
      if (authorId.includes('id.ndl.go.jp')) {
        return 'japanese';
      }
      
      // For other cases, fallback to mixed search
      return 'mixed';
    }

    // Locale-specific endpoint configuration
    const localeConfig = {
      korean: {
        endpoints: ['knl'],
        priority: ['knl']
      },
      japanese: {
        endpoints: ['jpsearch', 'ndl'],
        priority: ['jpsearch', 'ndl']
      },
      english: {
        endpoints: ['ndl', 'jpsearch'],
        priority: ['ndl', 'jpsearch']
      },
      chinese: {
        endpoints: ['ndl', 'jpsearch'],
        priority: ['ndl', 'jpsearch']
      },
      mixed: {
        endpoints: ['jpsearch', 'ndl', 'knl'],
        priority: ['jpsearch', 'ndl', 'knl']
      },
      unknown: {
        endpoints: ['jpsearch', 'ndl', 'knl'],
        priority: ['jpsearch', 'ndl', 'knl']
      }
    };
    
    function logPerformance(operation, duration) {
      console.log(`Performance: ${operation} took ${duration}ms`);
      if (operation === 'search') {
        performanceMetrics.searchTimes.push(duration);
        // Keep only last 10 search times
        if (performanceMetrics.searchTimes.length > 10) {
          performanceMetrics.searchTimes.shift();
        }
      }
    }

    async function searchKNLAuthors(name, strategy, signal = null) {
      console.log('KNL Search Input:', name); // Debug logging
      
      const startTime = performance.now();
      
      // Check cache first
      const cacheKey = `knl_${name}_${strategy}`;
      const cachedResult = searchCache.get(cacheKey);
      if (cachedResult && Date.now() - cachedResult.timestamp < CACHE_DURATION) {
        console.log('Using cached KNL results for:', name);
        performanceMetrics.cacheHits++;
        logPerformance('KNL search (cached)', performance.now() - startTime);
        return cachedResult.data;
      }
      
      performanceMetrics.cacheMisses++;
      
      // Clean the search name - remove extra formatting from NDL names
      let cleanName = name;
      if (name.includes(',')) {
        // If it's a formatted name like "유, 시민, 1959-", extract just the name parts
        const parts = name.split(',').map(p => p.trim());
        if (parts.length >= 2) {
          cleanName = parts[0] + parts[1]; // "유시민"
        }
      }
      
      // Try multiple name variations for KNL (working patterns only)
      const nameVariations = [];
      
      // Variation 1: Clean name (e.g., "유시민")
      nameVariations.push(cleanName);
      
      // Variation 2: Original name if different
      if (cleanName !== name) {
        nameVariations.push(name);
      }
      
      // Try each name variation until we get results (using only exact match - CONTAINS fails)
      for (let i = 0; i < nameVariations.length; i++) {
        const searchName = nameVariations[i];
        console.log(`KNL Strategy ${i + 1}: Exact match for "${searchName}"`); // Debug logging
        
        // Use the working modular query pattern (exact match only)
        const knlQuery = SparqlQueries.knl.authorByName(searchName);

        // Use local CORS proxy for KNL since the endpoint doesn't support CORS
        const knlDirectUrl = `${knlEndpoint}?query=${encodeURIComponent(knlQuery)}&format=json&type=json`;
        const knlUrl = `http://localhost:8001/?url=${encodeURIComponent(knlDirectUrl)}`;
        
        try {
          const fetchOptions = signal ? { signal } : {};
          const knlData = await fetch(knlUrl, fetchOptions).then(res => {
            if (!res.ok) {
              if (res.status === 0 || res.status >= 500) {
                throw new Error('KNL proxy not available');
              }
              throw new Error(`HTTP ${res.status}`);
            }
            return res.json();
          });
          console.log(`KNL Strategy ${i + 1} Response:`, knlData); // Debug logging
          console.log(`Sample binding for ${name}:`, knlData?.results?.bindings?.[0]); // Debug individual record
          
          if (knlData && knlData.results && knlData.results.bindings && knlData.results.bindings.length > 0) {
            console.log(`KNL Success with strategy ${i + 1}:`, knlData.results.bindings.length, 'results');
            
            // Cache successful results
            searchCache.set(cacheKey, {
              data: knlData.results.bindings,
              timestamp: Date.now()
            });
            
            logPerformance('KNL search', performance.now() - startTime);
            return knlData.results.bindings;
          }
        } catch (error) {
          if (error.name === 'AbortError') {
            console.log('KNL search cancelled');
            throw error;
          }
          
          console.warn(`KNL search strategy ${i + 1} failed for "${searchName}":`, error.message);
          if (error.message.includes('proxy not available')) {
            console.warn('KNL proxy is not running - KNL searches will be disabled');
            window.lastKNLError = error.message; // Track error state
            
            // Cache empty result for proxy unavailable
            searchCache.set(cacheKey, {
              data: [],
              timestamp: Date.now()
            });
            
            return []; // Stop trying other strategies if proxy is down
          }
          // Continue to next strategy for other errors
        }
      }
      
      console.log('KNL: No results found with any strategy');
      
      // Cache empty result
      searchCache.set(cacheKey, {
        data: [],
        timestamp: Date.now()
      });
      
      logPerformance('KNL search (no results)', performance.now() - startTime);
      return []; // No results found with any strategy
    }

    function buildJPSearchQuery(name, strategy) {
      const searchWords = name.toLowerCase().split(/\s+/).filter(w => w.length > 0);
      
      if (searchWords.length <= 1) {
        // Single word - use simple search
        const searchFilters = `CONTAINS(LCASE(?authorName), "${searchWords[0]}") || ` + 
          `CONTAINS(LCASE(REPLACE(?authorName, "_", " ")), "${searchWords[0]}") || ` + 
          `CONTAINS(LCASE(REPLACE(?authorName, ",_", ", ")), "${searchWords[0]}")`;
        
        return `
PREFIX schema: <http://schema.org/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>

SELECT DISTINCT ?creator ?authorName
WHERE {
  ?s schema:creator ?creator ;
     schema:isbn ?isbn .
  BIND(REPLACE(STR(?creator), ".*/", "") AS ?authorName)
  FILTER(${searchFilters})
}
LIMIT 20`;
      }

      // Multi-word search with AND/OR strategy
      const wordFilters = searchWords.map(word => 
        `(CONTAINS(LCASE(?authorName), "${word}") || ` + 
        `CONTAINS(LCASE(REPLACE(?authorName, "_", " ")), "${word}") || ` + 
        `CONTAINS(LCASE(REPLACE(?authorName, ",_", ", ")), "${word}"))`
      );

      const joinOperator = strategy === 'AND' ? ' && ' : ' || ';
      const searchFilters = wordFilters.join(joinOperator);

      return `
PREFIX schema: <http://schema.org/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>

SELECT DISTINCT ?creator ?authorName
WHERE {
  ?s schema:creator ?creator ;
     schema:isbn ?isbn .
  BIND(REPLACE(STR(?creator), ".*/", "") AS ?authorName)
  FILTER(${searchFilters})
}
LIMIT 20`;
    }

    // Enhanced search that can match family name, given name, or full text  
    function buildNameSearchFilter(searchTerm) {
      // For Korean names, also try searching without comma/space separation
      // e.g., "이어령" should match "이, 어령"
      const koreanPattern = searchTerm.replace(/([가-힣])([가-힣])/, '$1, \s*$2');
      
      return `(regex(?name, "${searchTerm}", "i") || 
               regex(?label, "${searchTerm}", "i") ||
               regex(?transcription, "${searchTerm}", "i") ||
               regex(?koreanName, "${searchTerm}", "i") ||
               regex(?koreanName, "${koreanPattern}", "i") ||
               regex(REPLACE(?koreanName, ",\\s*", ""), "${searchTerm}", "i"))`;
    }

    function buildNDLQuery(name, strategy) {
      const searchWords = name.toLowerCase().split(/\s+/).filter(w => w.length > 0);
      
      if (searchWords.length <= 1) {
        // Single word search
        return `
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX schema: <http://schema.org/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX skosxl: <http://www.w3.org/2008/05/skos-xl#>
PREFIX ndl: <http://ndl.go.jp/dcndl/terms/>

SELECT DISTINCT ?s ?name ?label ?birthDate ?deathDate ?transcription ?koreanName
WHERE {
  ?s rdf:type foaf:Person;
     ^foaf:primaryTopic ?ndlna;
     foaf:name ?name.
  OPTIONAL { ?s schema:dateOfBirth ?birthDate. }
  OPTIONAL { ?s schema:dateOfDeath ?deathDate. }
  OPTIONAL { ?ndlna rdfs:label ?label. }
  OPTIONAL { 
    { ?ndlna skosxl:prefLabel ?prefLabel . ?prefLabel ndl:transcription ?transcription . }
    UNION
    { ?ndlna skosxl:altLabel ?altLabel . ?altLabel ndl:transcription ?transcription . }
  }
  OPTIONAL {
    { ?ndlna skosxl:prefLabel ?prefLabel2 . ?prefLabel2 skosxl:literalForm ?koreanName . }
    UNION
    { ?ndlna skosxl:altLabel ?altLabel2 . ?altLabel2 skosxl:literalForm ?koreanName . }
  }
  FILTER (${buildNameSearchFilter(searchWords[0])})
}
LIMIT 50`;
      }
      
      // Multi-word search with AND/OR strategy
      const wordFilters = searchWords.map(word => buildNameSearchFilter(word));
      
      const joinOperator = strategy === 'AND' ? ' && ' : ' || ';
      const searchFilters = wordFilters.join(joinOperator);
      
      return `
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX schema: <http://schema.org/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX skosxl: <http://www.w3.org/2008/05/skos-xl#>
PREFIX ndl: <http://ndl.go.jp/dcndl/terms/>

SELECT DISTINCT ?s ?name ?label ?birthDate ?deathDate ?transcription ?koreanName
WHERE {
  ?s rdf:type foaf:Person;
     ^foaf:primaryTopic ?ndlna;
     foaf:name ?name.
  OPTIONAL { ?s schema:dateOfBirth ?birthDate. }
  OPTIONAL { ?s schema:dateOfDeath ?deathDate. }
  OPTIONAL { ?ndlna rdfs:label ?label. }
  OPTIONAL { 
    { ?ndlna skosxl:prefLabel ?prefLabel . ?prefLabel ndl:transcription ?transcription . }
    UNION
    { ?ndlna skosxl:altLabel ?altLabel . ?altLabel ndl:transcription ?transcription . }
  }
  OPTIONAL {
    { ?ndlna skosxl:prefLabel ?prefLabel2 . ?prefLabel2 skosxl:literalForm ?koreanName . }
    UNION
    { ?ndlna skosxl:altLabel ?altLabel2 . ?altLabel2 skosxl:literalForm ?koreanName . }
  }
  FILTER (${searchFilters})
}
LIMIT 50`;
    }

    function displaySearchResults(ndlBindings, jpSearchBindings, knlBindings, searchMetadata = {}) {
      if (ndlBindings.length === 0 && jpSearchBindings.length === 0 && knlBindings.length === 0) {
        authorSearchResults.innerHTML = '<div style="color: #666;">No authors found.</div>';
        return;
      }
      
      // Merge and deduplicate authors from all sources
      const mergedAuthors = mergeAuthorResults(ndlBindings, jpSearchBindings, knlBindings);
      
      authorSearchResults.innerHTML = '';
      
      // Show language optimization info
      if (searchMetadata.detectedLanguage) {
        const langInfo = document.createElement('div');
        langInfo.style.fontSize = '0.85em';
        langInfo.style.color = '#0066cc';
        langInfo.style.marginBottom = '10px';
        langInfo.style.padding = '6px';
        langInfo.style.backgroundColor = '#e8f4fd';
        langInfo.style.borderRadius = '4px';
        langInfo.style.border = '1px solid #b3d9f7';
        
        let langText = `🌐 Language: ${searchMetadata.detectedLanguage} | Optimized search`;
        if (searchMetadata.skippedEndpoints && searchMetadata.skippedEndpoints.length > 0) {
          langText += ` (skipped: ${searchMetadata.skippedEndpoints.join(', ')})`;
        }
        
        langInfo.textContent = langText;
        authorSearchResults.appendChild(langInfo);
      }
      
      // Show summary of sources at top
      const summary = document.createElement('div');
      summary.style.fontSize = '0.9em';
      summary.style.color = '#666';
      summary.style.marginBottom = '15px';
      summary.style.padding = '8px';
      summary.style.backgroundColor = '#f8f9fa';
      summary.style.borderRadius = '4px';
      summary.style.border = '1px solid #dee2e6';
      
      let summaryText = `Found ${ndlBindings.length} from NDL, ${jpSearchBindings.length} from JPSearch, ${knlBindings.length} from KNL`;
      
      // Check if KNL searches failed due to proxy issues
      const knlProxyDown = knlBindings.length === 0 && window.lastKNLError && window.lastKNLError.includes('proxy not available');
      if (knlProxyDown) {
        summaryText += ' (⚠️ KNL unavailable - proxy not running)';
      }
      
      summary.textContent = summaryText;
      authorSearchResults.appendChild(summary);

      // Create selection interface for multiple results
      if (mergedAuthors.length > 1) {
        const selectionHeader = document.createElement('h3');
        selectionHeader.textContent = 'Select Author:';
        selectionHeader.style.marginBottom = '10px';
        selectionHeader.style.fontSize = '1.1em';
        authorSearchResults.appendChild(selectionHeader);

        // Create radio button selection for better UX
        const form = document.createElement('form');
        form.style.marginBottom = '15px';
        
        mergedAuthors.forEach((author, index) => {
          const div = document.createElement('div');
          div.style.padding = '8px';
          div.style.margin = '4px 0';
          div.style.borderRadius = '4px';
          div.style.border = '1px solid #ddd';
          div.style.backgroundColor = '#fff';
          div.style.cursor = 'pointer';
          div.style.transition = 'all 0.2s';
          
          const radio = document.createElement('input');
          radio.type = 'radio';
          radio.name = 'authorSelect';
          radio.value = author.preferredId;
          radio.id = `author_${index}`;
          radio.style.marginRight = '8px';
          
          const label = document.createElement('label');
          label.htmlFor = `author_${index}`;
          label.textContent = author.displayName;
          label.style.cursor = 'pointer';
          label.style.flex = '1';
          label.style.display = 'block';
          
          div.appendChild(radio);
          div.appendChild(label);
          
          // Add hover effects
          div.addEventListener('mouseenter', () => {
            div.style.backgroundColor = '#f0f8ff';
            div.style.borderColor = '#007AFF';
          });
          
          div.addEventListener('mouseleave', () => {
            if (!radio.checked) {
              div.style.backgroundColor = '#fff';
              div.style.borderColor = '#ddd';
            }
          });
          
          // Make entire div clickable
          div.addEventListener('click', () => {
            radio.checked = true;
            updateRadioVisualState(form, div);
          });
          
          // Keyboard navigation
          div.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              radio.checked = true;
              updateRadioVisualState(form, div);
            }
          });
          
          div.setAttribute('tabindex', '0');
          div.setAttribute('role', 'radio');
          div.setAttribute('aria-checked', 'false');
          
          radio.addEventListener('change', () => {
            if (radio.checked) {
              updateRadioVisualState(form, div);
              div.setAttribute('aria-checked', 'true');
            }
          });
          
          form.appendChild(div);
        });
        
        // Add selection button
        const selectButton = document.createElement('button');
        selectButton.type = 'button';
        selectButton.textContent = 'Select Author';
        selectButton.style.marginTop = '10px';
        selectButton.style.padding = '10px 20px';
        selectButton.style.backgroundColor = '#007AFF';
        selectButton.style.color = 'white';
        selectButton.style.border = 'none';
        selectButton.style.borderRadius = '6px';
        selectButton.style.cursor = 'pointer';
        selectButton.style.fontSize = '14px';
        selectButton.style.fontWeight = '500';
        
        selectButton.addEventListener('click', () => {
          const selected = form.querySelector('input[name="authorSelect"]:checked');
          if (selected) {
            const selectedAuthor = mergedAuthors.find(a => a.preferredId === selected.value);
            if (selectedAuthor) {
              selectAuthor(selected.value, selectedAuthor.displayName);
            }
          } else {
            alert('Please select an author first.');
          }
        });
        
        form.appendChild(selectButton);
        authorSearchResults.appendChild(form);
        
      } else if (mergedAuthors.length === 1) {
        // Single result - show direct selection option
        const singleResult = document.createElement('div');
        singleResult.style.padding = '10px';
        singleResult.style.backgroundColor = '#f0f8ff';
        singleResult.style.border = '1px solid #007AFF';
        singleResult.style.borderRadius = '6px';
        singleResult.style.marginBottom = '10px';
        
        const author = mergedAuthors[0];
        const authorInfo = document.createElement('div');
        authorInfo.textContent = author.displayName;
        authorInfo.style.marginBottom = '8px';
        authorInfo.style.fontWeight = '500';
        
        const selectButton = document.createElement('button');
        selectButton.textContent = 'Select This Author';
        selectButton.style.padding = '8px 16px';
        selectButton.style.backgroundColor = '#007AFF';
        selectButton.style.color = 'white';
        selectButton.style.border = 'none';
        selectButton.style.borderRadius = '4px';
        selectButton.style.cursor = 'pointer';
        selectButton.style.fontSize = '14px';
        
        selectButton.addEventListener('click', () => {
          selectAuthor(author.preferredId, author.displayName);
        });
        
        singleResult.appendChild(authorInfo);
        singleResult.appendChild(selectButton);
        authorSearchResults.appendChild(singleResult);
      }
      
      // Show global authority identifier matches
      if (jpSearchBindings.length > 0 || knlBindings.length > 0) {
        const globalLinks = extractGlobalAuthorityLinks(jpSearchBindings, knlBindings);
        if (globalLinks.length > 0) {
          const globalDiv = document.createElement('div');
          globalDiv.style.fontSize = '0.85em';
          globalDiv.style.color = '#0066cc';
          globalDiv.style.marginTop = '10px';
          globalDiv.style.padding = '6px';
          globalDiv.style.backgroundColor = '#f8f9fa';
          globalDiv.style.borderRadius = '4px';
          globalDiv.innerHTML = `🌐 Global Authority IDs: ${globalLinks.join(', ')}`;
          authorSearchResults.appendChild(globalDiv);
        }
      }
    }

    function extractGlobalAuthorityLinks(jpSearchBindings, knlBindings) {
      const globalIds = new Set();
      
      // Extract from JPSearch results
      jpSearchBindings.forEach(binding => {
        if (binding.viafId) globalIds.add(`<a href="${binding.viafId.value}" target="_blank">VIAF</a>`);
        if (binding.wikidataId) globalIds.add(`<a href="${binding.wikidataId.value}" target="_blank">Wikidata</a>`);
        if (binding.dbpediaId) globalIds.add(`<a href="${binding.dbpediaId.value}" target="_blank">DBpedia</a>`);
      });
      
      // Extract from KNL results  
      knlBindings.forEach(binding => {
        if (binding.gndId) globalIds.add(`<a href="${binding.gndId.value}" target="_blank">GND</a>`);
        if (binding.bnfId) globalIds.add(`<a href="${binding.bnfId.value}" target="_blank">BnF</a>`);
        if (binding.dbpediaId) globalIds.add(`<a href="${binding.dbpediaId.value}" target="_blank">DBpedia</a>`);
        if (binding.locId) globalIds.add(`<a href="${binding.locId.value}" target="_blank">LoC</a>`);
        if (binding.ndlId) globalIds.add(`<a href="${binding.ndlId.value}" target="_blank">NDL</a>`);
      });
      
      return Array.from(globalIds);
    }

    // Function to merge and deduplicate author results
    function mergeAuthorResults(ndlBindings, jpSearchBindings, knlBindings) {
      const authorMap = new Map();
      
      // Process NDL results first
      ndlBindings.forEach(binding => {
        const authorId = binding.s.value;
        const authorName = binding.label.value || binding.name.value;
        const birthDate = binding.birthDate ? binding.birthDate.value : null;
        const deathDate = binding.deathDate ? binding.deathDate.value : null;
        const transcription = binding.transcription ? binding.transcription.value : null;
        const koreanName = binding.koreanName ? binding.koreanName.value : null;
        
        const author = {
          ndlId: authorId,
          ndlName: authorName,
          baseName: normalizeAuthorName(authorName),
          birthDate: birthDate,
          deathDate: deathDate,
          transcription: transcription,
          koreanName: koreanName,
          hasISBN: false,
          jpSearchId: null,
          knlId: null
        };
        
        authorMap.set(authorId, author);
      });
      
      // Process JPSearch results and merge with NDL
      jpSearchBindings.forEach(binding => {
        const ndlId = binding.ndlId;
        
        if (authorMap.has(ndlId)) {
          // Merge with existing NDL entry
          const existing = authorMap.get(ndlId);
          existing.hasISBN = true;
          existing.jpSearchId = binding.creator.value;
        } else {
          // This case should not happen if the logic in searchAuthorsWithStrategy is correct
        }
      });

      // Process KNL results - deduplicate by KNL URI and combine job titles
      const knlAuthorMap = new Map();
      
      knlBindings.forEach((binding) => {
        const knlId = binding.s.value;
        const knlName = binding.label.value;
        const normalizedName = normalizeAuthorName(knlName);
        
        // Extract biographical information from KNL
        const jobTitle = binding.jobTitle ? binding.jobTitle.value : null;
        const fieldOfActivity = binding.fieldOfActivity ? binding.fieldOfActivity.value : null;
        const gender = binding.gender ? binding.gender.value : null;
        const source = binding.source ? binding.source.value : null;
        const associatedLanguage = binding.associatedLanguage ? binding.associatedLanguage.value : null;
        
        if (knlAuthorMap.has(knlId)) {
          // Merge with existing entry
          const existingAuthor = knlAuthorMap.get(knlId);
          
          // Combine job titles
          const jobTitles = new Set();
          if (existingAuthor.jobTitle) jobTitles.add(existingAuthor.jobTitle);
          if (jobTitle) jobTitles.add(jobTitle);
          existingAuthor.jobTitle = Array.from(jobTitles).join(', ');
          
          // Keep other fields (they should be the same for the same person)
          if (!existingAuthor.fieldOfActivity && fieldOfActivity) existingAuthor.fieldOfActivity = fieldOfActivity;
          if (!existingAuthor.gender && gender) existingAuthor.gender = gender;
          if (!existingAuthor.source && source) existingAuthor.source = source;
          if (!existingAuthor.associatedLanguage && associatedLanguage) existingAuthor.associatedLanguage = associatedLanguage;
          
        } else {
          // Create new KNL author entry
          const knlAuthor = {
            ndlId: null,
            ndlName: null,
            baseName: normalizedName,
            jobTitle: jobTitle,
            fieldOfActivity: fieldOfActivity,
            gender: gender,
            source: source,
            associatedLanguage: associatedLanguage,
            transcription: null,
            koreanName: knlName,
            hasISBN: false,
            jpSearchId: null,
            knlId: knlId,
            knlName: knlName,
            // Add global authority IDs from KNL if available
            globalIds: []
          };
          
          // Extract global authority links
          if (binding.gndId) knlAuthor.globalIds.push(binding.gndId.value);
          if (binding.bnfId) knlAuthor.globalIds.push(binding.bnfId.value);
          if (binding.dbpediaId) knlAuthor.globalIds.push(binding.dbpediaId.value);
          if (binding.locId) knlAuthor.globalIds.push(binding.locId.value);
          if (binding.ndlId) knlAuthor.globalIds.push(binding.ndlId.value);
          
          knlAuthorMap.set(knlId, knlAuthor);
        }
      });
      
      // Add deduplicated KNL authors to main author map
      knlAuthorMap.forEach((knlAuthor, knlId) => {
        authorMap.set(`knl_${knlId.split('/').pop()}`, knlAuthor);
      });
      
      // Convert to array with display formatting
      return Array.from(authorMap.values()).map(author => {
        let displayName, preferredId;
        
        if (author.hasISBN) {
          // Prefer ISBN version, use NDL name if available for better formatting
          displayName = author.ndlName || author.jpSearchName || author.baseName;
          
          // Parse and display name components
          if (author.ndlName) {
            const nameComponents = parseNameComponents(author.ndlName);
            if (nameComponents.familyName && nameComponents.givenName) {
              displayName += ` [${nameComponents.familyName} | ${nameComponents.givenName}]`;
            }
          }
          
          if (author.koreanName) displayName += ` / ${author.koreanName}`;
          if (author.transcription) displayName += ` / ${author.transcription}`;
          if (author.birthDate) displayName += ` (${author.birthDate})`;
          if (author.deathDate) displayName += ` - ${author.deathDate}`;
          if (author.knlId) displayName += ' 🇰🇷'; // KNL indicator
          if (author.globalIds && author.globalIds.length > 0) displayName += ' 🌐'; // Global ID indicator
          displayName += ' 📚'; // ISBN indicator
          preferredId = author.jpSearchId;
        } else if (author.knlId && !author.ndlId) {
          // KNL-only author with biographical details
          displayName = author.knlName;
          
          // Add human-readable distinguishing information for Korean names
          const bioDetails = [];
          
          // Job title (occupation)
          if (author.jobTitle) {
            bioDetails.push(author.jobTitle);
          }
          
          // Field of activity (more specific than job title)
          if (author.fieldOfActivity && author.fieldOfActivity !== author.jobTitle) {
            bioDetails.push(author.fieldOfActivity);
          }
          
          // Source - often contains book titles or publication info that helps identify the person
          if (author.source) {
            // Extract meaningful info from source (usually book titles)
            let sourceInfo = author.source;
            // If it contains a book title and publisher, extract just the book title
            const bookMatch = sourceInfo.match(/^([^,]+),?\s*\(/);
            if (bookMatch) {
              sourceInfo = bookMatch[1].trim();
            }
            // Truncate if too long
            if (sourceInfo.length > 40) {
              sourceInfo = sourceInfo.substring(0, 37) + '...';
            }
            bioDetails.push(`"${sourceInfo}"`);
          }
          
          // Gender (if available and helps distinguish)
          if (author.gender && author.gender !== '남성') { // Only show if not male (since most are male)
            bioDetails.push(author.gender);
          }
          
          // If still no meaningful distinguishing info, use KNL ID as fallback
          if (bioDetails.length === 0) {
            const uriPart = author.knlId.split('/').pop();
            bioDetails.push(`ID:${uriPart}`);
          }
          
          if (bioDetails.length > 0) {
            displayName += ` (${bioDetails.join(' | ')})`;
          }
          
          displayName += ' 🇰🇷'; // KNL indicator
          if (author.globalIds && author.globalIds.length > 0) displayName += ' 🌐'; // Global ID indicator
          preferredId = author.knlId;
        } else {
          // NDL-only author
          displayName = author.ndlName;
          
          // Parse and display name components
          if (author.ndlName) {
            const nameComponents = parseNameComponents(author.ndlName);
            if (nameComponents.familyName && nameComponents.givenName) {
              displayName += ` [${nameComponents.familyName} | ${nameComponents.givenName}]`;
            }
          }
          
          if (author.koreanName) displayName += ` / ${author.koreanName}`;
          if (author.transcription) displayName += ` / ${author.transcription}`;
          if (author.birthDate) displayName += ` (${author.birthDate})`;
          if (author.deathDate) displayName += ` - ${author.deathDate}`;
          if (author.knlId) displayName += ' 🇰🇷'; // KNL indicator
          if (author.globalIds && author.globalIds.length > 0) displayName += ' 🌐'; // Global ID indicator
          preferredId = author.ndlId;
        }
        
        return {
          preferredId: preferredId,
          displayName: displayName,
          baseName: author.baseName,
          hasISBN: author.hasISBN,
          hasKNL: !!author.knlId
        };
      });
    }
    
    // Parse family and given names from structured NDL labels
    function parseNameComponents(labelText) {
      if (!labelText) return { familyName: null, givenName: null, fullName: labelText };
      
      // Pattern: "FAMILY, GIVEN, DATES" (e.g., "柄谷, 行人, 1941-" or "이, 어령, 1934-2022")
      const match = labelText.match(/^([^,]+),\s*([^,]+)(?:,\s*.+)?$/);
      
      if (match) {
        return {
          familyName: match[1].trim(),
          givenName: match[2].trim(),
          fullName: labelText
        };
      }
      
      return { familyName: null, givenName: null, fullName: labelText };
    }

    // Normalize author names for matching
    function normalizeAuthorName(name) {
      if (!name) return '';
      // Remove common punctuation, spaces, dates, and convert to lowercase for matching
      return name
        .replace(/,\s*\d{4}[\-\d]*\s*$/g, '')     // Remove trailing dates like ", 1953-"
        .replace(/[\s\-\(\)\（\）_]/g, '')          // Remove punctuation, spaces, and underscores
        .toLowerCase();
    }

    // Helper function to update radio button visual states
    function updateRadioVisualState(form, selectedDiv) {
      // Reset all divs
      form.querySelectorAll('div[role="radio"]').forEach(d => {
        d.style.backgroundColor = '#fff';
        d.style.borderColor = '#ddd';
        d.setAttribute('aria-checked', 'false');
      });
      
      // Highlight selected div
      selectedDiv.style.backgroundColor = '#e3f2fd';
      selectedDiv.style.borderColor = '#007AFF';
      selectedDiv.setAttribute('aria-checked', 'true');
    }

    // Function to select an author and add to dropdown
    function selectAuthor(authorId, displayName) {
      fetchWorks(authorId);
      
      // Update the author select dropdown
      let optionExists = false;
      for (let i = 0; i < authorSelect.options.length; i++) {
        if (authorSelect.options[i].value === authorId) {
          authorSelect.selectedIndex = i;
          optionExists = true;
          break;
        }
      }
      if (!optionExists) {
        const newOption = document.createElement('option');
        newOption.value = authorId;
        newOption.textContent = displayName;
        authorSelect.prepend(newOption);
        addAuthorToDb({ id: authorId, name: displayName });
      }
      authorSelect.value = authorId;
      localStorage.setItem('lastSelectedAuthor', authorId);
      
      // Hide search results after selection
      authorSearchResults.style.display = 'none';
      
      // Clear search input
      authorSearchInput.value = '';
    }

    // Helper function to create author links (deprecated - use selectAuthor instead)
    function createAuthorLink(li, authorId, displayName, authorName) {
      const a = document.createElement('a');
      a.href = '#';
      a.textContent = displayName;
      a.addEventListener('click', (e) => {
        e.preventDefault();
        selectAuthor(authorId, displayName);
      });
      li.appendChild(a);
    }
  </script>
</body>
</html>
